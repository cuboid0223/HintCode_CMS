{"version":3,"file":"index.es.js","sources":["../src/hooks/useFirestoreCollectionsConfigController.tsx"],"sourcesContent":["import React, { useCallback, useEffect, useMemo } from \"react\";\nimport { FirebaseApp } from \"firebase/app\";\nimport { collection, deleteDoc, doc, getFirestore, onSnapshot, runTransaction } from \"firebase/firestore\";\nimport {\n    CollectionsConfigController,\n    DeleteCollectionParams,\n    namespaceToPropertiesPath,\n    PersistedCollection,\n    SaveCollectionParams,\n    UpdateCollectionParams\n} from \"@firecms/collection_editor\";\nimport {\n    applyPermissionsFunctionIfEmpty,\n    PermissionsBuilder,\n    Property,\n    PropertyConfig,\n    removeFunctions,\n    removeUndefined,\n    User\n} from \"@firecms/core\";\nimport {\n    buildCollectionId,\n    docsToCollectionTree,\n    prepareCollectionForPersistence,\n    setUndefinedToDelete\n} from \"@firecms/firebase\";\n\n/**\n * @group Firebase\n */\nexport interface CollectionConfigControllerProps<EC extends PersistedCollection, UserType extends User = User> {\n\n    firebaseApp?: FirebaseApp;\n\n    /**\n     * Firestore document where the configuration is saved. e.g. \"projects/my_project\"\n     * Must be a 2 path string.\n     */\n    configPath?: string;\n\n    /**\n     * Define what actions can be performed on data.\n     */\n    permissions?: PermissionsBuilder<EC, UserType>;\n\n    /**\n     * If you are defining custom properties, you can pass them here.\n     */\n    propertyConfigs?: PropertyConfig[]\n\n}\n\n/**\n * Build a {@link CollectionsConfigController} that persists collection in\n * Firestore, but also allows including collections added in code.\n * @param firebaseApp\n * @param collections\n * @param configPath\n */\nexport function useFirestoreCollectionsConfigController<EC extends PersistedCollection, UserType extends User = User>({\n                                                                                                                          firebaseApp,\n                                                                                                                          configPath = \"__FIRECMS/config/collections\",\n                                                                                                                          permissions,\n                                                                                                                          propertyConfigs\n                                                                                                                      }: CollectionConfigControllerProps<EC, UserType>): CollectionsConfigController {\n\n    const propertyConfigsMap = useMemo(() => {\n        const map: Record<string, any> = {};\n        propertyConfigs?.forEach(field => {\n            map[field.key] = field;\n        });\n        return map;\n    }, [propertyConfigs]);\n\n    const [collectionsLoading, setCollectionsLoading] = React.useState<boolean>(true);\n    const [persistedCollections, setPersistedCollections] = React.useState<PersistedCollection[] | undefined>();\n\n    const [collectionsError, setCollectionsError] = React.useState<Error | undefined>();\n\n    useEffect(() => {\n        if (!firebaseApp || !configPath) return;\n\n        const firestore = getFirestore(firebaseApp);\n\n        return onSnapshot(collection(firestore, configPath),\n            {\n                next: (snapshot) => {\n                    setCollectionsError(undefined);\n                    try {\n                        const newCollections = docsToCollectionTree(snapshot.docs);\n                        setPersistedCollections(newCollections);\n                    } catch (e) {\n                        console.error(e);\n                        setCollectionsError(e as Error);\n                    }\n                    setCollectionsLoading(false);\n                },\n                error: (e) => {\n                    setCollectionsLoading(false);\n                    setCollectionsError(e);\n                }\n            }\n        );\n    }, [configPath, firebaseApp]);\n\n    const deleteCollection = useCallback(({\n                                              id,\n                                              parentCollectionIds\n                                          }: DeleteCollectionParams): Promise<void> => {\n\n        if (!firebaseApp || !configPath) throw Error(\"useFirestoreConfigurationPersistence Firestore not initialised\");\n        const firestore = getFirestore(firebaseApp);\n        const collectionPath = buildCollectionId(id, parentCollectionIds);\n        console.debug(\"!!Deleting collection\", collectionPath);\n        const ref = doc(firestore, configPath, collectionPath);\n        return deleteDoc(ref);\n    }, [configPath, firebaseApp]);\n\n    const saveCollection = useCallback(<M extends Record<string, any>>({\n                                                                           id,\n                                                                           collectionData,\n                                                                           previousId,\n                                                                           parentCollectionIds\n                                                                       }: SaveCollectionParams<M>): Promise<void> => {\n        if (!firebaseApp || !configPath) throw Error(\"useFirestoreConfigurationPersistence Firestore not initialised\");\n        const firestore = getFirestore(firebaseApp);\n        if (!id)\n            throw Error(\"Trying to save a collection with no id\");\n        if (!collectionData.path)\n            throw Error(\"Trying to save a collection with no path\");\n        if (!collectionData.name)\n            throw Error(\"Trying to save a collection with no name\");\n        const cleanedCollection = prepareCollectionForPersistence(collectionData, propertyConfigsMap);\n        const strippedPath = buildCollectionId(id, parentCollectionIds);\n        const previousStrippedId = previousId ? buildCollectionId(previousId, parentCollectionIds) : undefined;\n        const ref = doc(firestore, configPath, strippedPath);\n        console.debug(\"Saving collection\", {\n            id,\n            collectionData,\n            previousId,\n            parentCollectionIds,\n            cleanedCollection\n        });\n        return runTransaction(firestore, async (transaction) => {\n            transaction.set(ref, cleanedCollection, { merge: true });\n            if (previousStrippedId && previousStrippedId !== strippedPath) {\n                const previousRef = doc(firestore, configPath, previousStrippedId);\n                transaction.delete(previousRef);\n            }\n        });\n    }, [configPath, firebaseApp, propertyConfigsMap]);\n\n    const updateCollection = useCallback(<M extends Record<string, any>>({\n                                                                             id,\n                                                                             collectionData,\n                                                                             previousId,\n                                                                             parentCollectionIds\n                                                                         }: UpdateCollectionParams<M>): Promise<void> => {\n        if (!firebaseApp || !configPath) throw Error(\"useFirestoreConfigurationPersistence Firestore not initialised\");\n        const firestore = getFirestore(firebaseApp);\n        const cleanedCollection = prepareCollectionForPersistence(collectionData, propertyConfigsMap);\n        const strippedPath = buildCollectionId(id, parentCollectionIds);\n        const previousStrippedPath = previousId ? buildCollectionId(previousId, parentCollectionIds) : undefined;\n        const ref = doc(firestore, configPath, strippedPath);\n\n        console.debug(\"Updating collection\", {\n            id,\n            collectionData,\n            previousId,\n            parentCollectionIds,\n            cleanedCollection\n        });\n\n        return runTransaction(firestore, async (transaction) => {\n            transaction.set(ref, cleanedCollection, { merge: true });\n            if (previousStrippedPath && previousStrippedPath !== strippedPath) {\n                const previousRef = doc(firestore, configPath, previousStrippedPath);\n                transaction.delete(previousRef);\n            }\n        });\n    }, [configPath, firebaseApp, propertyConfigsMap]);\n\n    const collections = persistedCollections !== undefined ? applyPermissionsFunctionIfEmpty(persistedCollections, permissions as PermissionsBuilder<any, any>) : undefined;\n\n    const getCollection = useCallback((id: string) => {\n        if (!collections) throw Error(\"Collections not initialised\");\n        const collection = collections.find(c => c.id === id);\n        if (!collection) throw Error(`Collection with id ${id} not found`);\n        return collection;\n    }, [collections]);\n\n    const saveProperty = useCallback(({\n                                          path,\n                                          propertyKey,\n                                          property,\n                                          newPropertiesOrder,\n                                          parentCollectionIds,\n                                          namespace\n                                      }: {\n        path: string,\n        propertyKey: string,\n        property: Property,\n        newPropertiesOrder?: string[],\n        parentCollectionIds?: string[],\n        namespace?: string\n    }): Promise<void> => {\n\n        if (!firebaseApp || !configPath) throw Error(\"useFirestoreConfigurationPersistence Firestore not initialised\");\n        const firestore = getFirestore(firebaseApp);\n        const collectionPath = buildCollectionId(path, parentCollectionIds);\n        const ref = doc(firestore, configPath, collectionPath);\n        return runTransaction(firestore, async (transaction) => {\n            const data = {\n                [namespaceToPropertiesPath(namespace) + \".\" + propertyKey]: setUndefinedToDelete(removeFunctions(removeUndefined(property))),\n            };\n            if (newPropertiesOrder) {\n                data.propertiesOrder = newPropertiesOrder;\n            }\n            console.log(\"Saving property\", {\n                path,\n                propertyKey,\n                property,\n                collectionPath,\n                namespace,\n                data\n            });\n            transaction.update(ref, data);\n        });\n\n    }, [configPath, firebaseApp]);\n\n    const deleteProperty = useCallback(({\n                                            path,\n                                            propertyKey,\n                                            newPropertiesOrder,\n                                            parentCollectionIds,\n                                            namespace\n                                        }: {\n        path: string,\n        propertyKey: string,\n        newPropertiesOrder?: string[],\n        parentCollectionIds?: string[],\n        namespace?: string\n    }): Promise<void> => {\n\n        if (!firebaseApp || !configPath) throw Error(\"useFirestoreConfigurationPersistence Firestore not initialised\");\n        const firestore = getFirestore(firebaseApp);\n        const collectionPath = buildCollectionId(path, parentCollectionIds);\n        const ref = doc(firestore, configPath, collectionPath);\n        return runTransaction(firestore, async (transaction) => {\n            const data: any = setUndefinedToDelete({\n                [namespaceToPropertiesPath(namespace) + \".\" + propertyKey]: undefined,\n            });\n            if (newPropertiesOrder) {\n                data.propertiesOrder = newPropertiesOrder;\n            }\n            console.log(\"Deleting property\", {\n                path,\n                propertyKey,\n                collectionPath,\n                namespace,\n                data\n            });\n            transaction.update(ref, data);\n        });\n    }, [configPath, firebaseApp]);\n\n    return useMemo(() => ({\n        loading: collectionsLoading,\n        collections,\n        getCollection,\n        saveCollection,\n        updateCollection,\n        deleteCollection,\n        saveProperty,\n        deleteProperty,\n    }), [collectionsLoading, collections, getCollection, saveCollection, updateCollection, deleteCollection, saveProperty, deleteProperty])\n}\n"],"names":["useFirestoreCollectionsConfigController","firebaseApp","configPath","permissions","propertyConfigs","propertyConfigsMap","useMemo","map","field","collectionsLoading","setCollectionsLoading","React","persistedCollections","setPersistedCollections","collectionsError","setCollectionsError","useEffect","firestore","getFirestore","onSnapshot","collection","snapshot","newCollections","docsToCollectionTree","e","deleteCollection","useCallback","id","parentCollectionIds","collectionPath","buildCollectionId","ref","doc","deleteDoc","saveCollection","collectionData","previousId","cleanedCollection","prepareCollectionForPersistence","strippedPath","previousStrippedId","runTransaction","transaction","previousRef","updateCollection","previousStrippedPath","collections","applyPermissionsFunctionIfEmpty","getCollection","c","saveProperty","path","propertyKey","property","newPropertiesOrder","namespace","data","namespaceToPropertiesPath","setUndefinedToDelete","removeFunctions","removeUndefined","deleteProperty"],"mappings":"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"}