import g, { useMemo as j, useEffect as H, useCallback as v } from "react";
import { getFirestore as f, onSnapshot as J, collection as N, doc as E, deleteDoc as O, runTransaction as y } from "firebase/firestore";
import { namespaceToPropertiesPath as q } from "@firecms/collection_editor";
import { applyPermissionsFunctionIfEmpty as Q, removeFunctions as V, removeUndefined as W } from "@firecms/core";
import { docsToCollectionTree as X, buildCollectionId as F, prepareCollectionForPersistence as z, setUndefinedToDelete as B } from "@firecms/firebase";
function b({
  firebaseApp: n,
  configPath: r = "__FIRECMS/config/collections",
  permissions: D,
  propertyConfigs: T
}) {
  const a = j(() => {
    const e = {};
    return T?.forEach((o) => {
      e[o.key] = o;
    }), e;
  }, [T]), [h, R] = g.useState(!0), [M, G] = g.useState(), [Y, S] = g.useState();
  H(() => {
    if (!n || !r)
      return;
    const e = f(n);
    return J(
      N(e, r),
      {
        next: (o) => {
          S(void 0);
          try {
            const t = X(o.docs);
            G(t);
          } catch (t) {
            console.error(t), S(t);
          }
          R(!1);
        },
        error: (o) => {
          R(!1), S(o);
        }
      }
    );
  }, [r, n]);
  const U = v(({
    id: e,
    parentCollectionIds: o
  }) => {
    if (!n || !r)
      throw Error("useFirestoreConfigurationPersistence Firestore not initialised");
    const t = f(n), s = F(e, o);
    console.debug("!!Deleting collection", s);
    const i = E(t, r, s);
    return O(i);
  }, [r, n]), k = v(({
    id: e,
    collectionData: o,
    previousId: t,
    parentCollectionIds: s
  }) => {
    if (!n || !r)
      throw Error("useFirestoreConfigurationPersistence Firestore not initialised");
    const i = f(n);
    if (!e)
      throw Error("Trying to save a collection with no id");
    if (!o.path)
      throw Error("Trying to save a collection with no path");
    if (!o.name)
      throw Error("Trying to save a collection with no name");
    const l = z(o, a), u = F(e, s), c = t ? F(t, s) : void 0, C = E(i, r, u);
    return console.debug("Saving collection", {
      id: e,
      collectionData: o,
      previousId: t,
      parentCollectionIds: s,
      cleanedCollection: l
    }), y(i, async (d) => {
      if (d.set(C, l, { merge: !0 }), c && c !== u) {
        const m = E(i, r, c);
        d.delete(m);
      }
    });
  }, [r, n, a]), x = v(({
    id: e,
    collectionData: o,
    previousId: t,
    parentCollectionIds: s
  }) => {
    if (!n || !r)
      throw Error("useFirestoreConfigurationPersistence Firestore not initialised");
    const i = f(n), l = z(o, a), u = F(e, s), c = t ? F(t, s) : void 0, C = E(i, r, u);
    return console.debug("Updating collection", {
      id: e,
      collectionData: o,
      previousId: t,
      parentCollectionIds: s,
      cleanedCollection: l
    }), y(i, async (d) => {
      if (d.set(C, l, { merge: !0 }), c && c !== u) {
        const m = E(i, r, c);
        d.delete(m);
      }
    });
  }, [r, n, a]), w = M !== void 0 ? Q(M, D) : void 0, L = v((e) => {
    if (!w)
      throw Error("Collections not initialised");
    const o = w.find((t) => t.id === e);
    if (!o)
      throw Error(`Collection with id ${e} not found`);
    return o;
  }, [w]), _ = v(({
    path: e,
    propertyKey: o,
    property: t,
    newPropertiesOrder: s,
    parentCollectionIds: i,
    namespace: l
  }) => {
    if (!n || !r)
      throw Error("useFirestoreConfigurationPersistence Firestore not initialised");
    const u = f(n), c = F(e, i), C = E(u, r, c);
    return y(u, async (d) => {
      const m = {
        [q(l) + "." + o]: B(V(W(t)))
      };
      s && (m.propertiesOrder = s), console.log("Saving property", {
        path: e,
        propertyKey: o,
        property: t,
        collectionPath: c,
        namespace: l,
        data: m
      }), d.update(C, m);
    });
  }, [r, n]), $ = v(({
    path: e,
    propertyKey: o,
    newPropertiesOrder: t,
    parentCollectionIds: s,
    namespace: i
  }) => {
    if (!n || !r)
      throw Error("useFirestoreConfigurationPersistence Firestore not initialised");
    const l = f(n), u = F(e, s), c = E(l, r, u);
    return y(l, async (C) => {
      const d = B({
        [q(i) + "." + o]: void 0
      });
      t && (d.propertiesOrder = t), console.log("Deleting property", {
        path: e,
        propertyKey: o,
        collectionPath: u,
        namespace: i,
        data: d
      }), C.update(c, d);
    });
  }, [r, n]);
  return j(() => ({
    loading: h,
    collections: w,
    getCollection: L,
    saveCollection: k,
    updateCollection: x,
    deleteCollection: U,
    saveProperty: _,
    deleteProperty: $
  }), [h, w, L, k, x, U, _, $]);
}
export {
  b as useFirestoreCollectionsConfigController
};
//# sourceMappingURL=index.es.js.map
