{"version":3,"file":"index.umd.js","sources":["../src/hooks/useFirestoreCollectionsConfigController.tsx"],"sourcesContent":["import React, { useCallback, useEffect, useMemo } from \"react\";\nimport { FirebaseApp } from \"firebase/app\";\nimport { collection, deleteDoc, doc, getFirestore, onSnapshot, runTransaction } from \"firebase/firestore\";\nimport {\n    CollectionsConfigController,\n    DeleteCollectionParams,\n    namespaceToPropertiesPath,\n    PersistedCollection,\n    SaveCollectionParams,\n    UpdateCollectionParams\n} from \"@firecms/collection_editor\";\nimport {\n    applyPermissionsFunctionIfEmpty,\n    PermissionsBuilder,\n    Property,\n    PropertyConfig,\n    removeFunctions,\n    removeUndefined,\n    User\n} from \"@firecms/core\";\nimport {\n    buildCollectionId,\n    docsToCollectionTree,\n    prepareCollectionForPersistence,\n    setUndefinedToDelete\n} from \"@firecms/firebase\";\n\n/**\n * @group Firebase\n */\nexport interface CollectionConfigControllerProps<EC extends PersistedCollection, UserType extends User = User> {\n\n    firebaseApp?: FirebaseApp;\n\n    /**\n     * Firestore document where the configuration is saved. e.g. \"projects/my_project\"\n     * Must be a 2 path string.\n     */\n    configPath?: string;\n\n    /**\n     * Define what actions can be performed on data.\n     */\n    permissions?: PermissionsBuilder<EC, UserType>;\n\n    /**\n     * If you are defining custom properties, you can pass them here.\n     */\n    propertyConfigs?: PropertyConfig[]\n\n}\n\n/**\n * Build a {@link CollectionsConfigController} that persists collection in\n * Firestore, but also allows including collections added in code.\n * @param firebaseApp\n * @param collections\n * @param configPath\n */\nexport function useFirestoreCollectionsConfigController<EC extends PersistedCollection, UserType extends User = User>({\n                                                                                                                          firebaseApp,\n                                                                                                                          configPath = \"__FIRECMS/config/collections\",\n                                                                                                                          permissions,\n                                                                                                                          propertyConfigs\n                                                                                                                      }: CollectionConfigControllerProps<EC, UserType>): CollectionsConfigController {\n\n    const propertyConfigsMap = useMemo(() => {\n        const map: Record<string, any> = {};\n        propertyConfigs?.forEach(field => {\n            map[field.key] = field;\n        });\n        return map;\n    }, [propertyConfigs]);\n\n    const [collectionsLoading, setCollectionsLoading] = React.useState<boolean>(true);\n    const [persistedCollections, setPersistedCollections] = React.useState<PersistedCollection[] | undefined>();\n\n    const [collectionsError, setCollectionsError] = React.useState<Error | undefined>();\n\n    useEffect(() => {\n        if (!firebaseApp || !configPath) return;\n\n        const firestore = getFirestore(firebaseApp);\n\n        return onSnapshot(collection(firestore, configPath),\n            {\n                next: (snapshot) => {\n                    setCollectionsError(undefined);\n                    try {\n                        const newCollections = docsToCollectionTree(snapshot.docs);\n                        setPersistedCollections(newCollections);\n                    } catch (e) {\n                        console.error(e);\n                        setCollectionsError(e as Error);\n                    }\n                    setCollectionsLoading(false);\n                },\n                error: (e) => {\n                    setCollectionsLoading(false);\n                    setCollectionsError(e);\n                }\n            }\n        );\n    }, [configPath, firebaseApp]);\n\n    const deleteCollection = useCallback(({\n                                              id,\n                                              parentCollectionIds\n                                          }: DeleteCollectionParams): Promise<void> => {\n\n        if (!firebaseApp || !configPath) throw Error(\"useFirestoreConfigurationPersistence Firestore not initialised\");\n        const firestore = getFirestore(firebaseApp);\n        const collectionPath = buildCollectionId(id, parentCollectionIds);\n        console.debug(\"!!Deleting collection\", collectionPath);\n        const ref = doc(firestore, configPath, collectionPath);\n        return deleteDoc(ref);\n    }, [configPath, firebaseApp]);\n\n    const saveCollection = useCallback(<M extends Record<string, any>>({\n                                                                           id,\n                                                                           collectionData,\n                                                                           previousId,\n                                                                           parentCollectionIds\n                                                                       }: SaveCollectionParams<M>): Promise<void> => {\n        if (!firebaseApp || !configPath) throw Error(\"useFirestoreConfigurationPersistence Firestore not initialised\");\n        const firestore = getFirestore(firebaseApp);\n        if (!id)\n            throw Error(\"Trying to save a collection with no id\");\n        if (!collectionData.path)\n            throw Error(\"Trying to save a collection with no path\");\n        if (!collectionData.name)\n            throw Error(\"Trying to save a collection with no name\");\n        const cleanedCollection = prepareCollectionForPersistence(collectionData, propertyConfigsMap);\n        const strippedPath = buildCollectionId(id, parentCollectionIds);\n        const previousStrippedId = previousId ? buildCollectionId(previousId, parentCollectionIds) : undefined;\n        const ref = doc(firestore, configPath, strippedPath);\n        console.debug(\"Saving collection\", {\n            id,\n            collectionData,\n            previousId,\n            parentCollectionIds,\n            cleanedCollection\n        });\n        return runTransaction(firestore, async (transaction) => {\n            transaction.set(ref, cleanedCollection, { merge: true });\n            if (previousStrippedId && previousStrippedId !== strippedPath) {\n                const previousRef = doc(firestore, configPath, previousStrippedId);\n                transaction.delete(previousRef);\n            }\n        });\n    }, [configPath, firebaseApp, propertyConfigsMap]);\n\n    const updateCollection = useCallback(<M extends Record<string, any>>({\n                                                                             id,\n                                                                             collectionData,\n                                                                             previousId,\n                                                                             parentCollectionIds\n                                                                         }: UpdateCollectionParams<M>): Promise<void> => {\n        if (!firebaseApp || !configPath) throw Error(\"useFirestoreConfigurationPersistence Firestore not initialised\");\n        const firestore = getFirestore(firebaseApp);\n        const cleanedCollection = prepareCollectionForPersistence(collectionData, propertyConfigsMap);\n        const strippedPath = buildCollectionId(id, parentCollectionIds);\n        const previousStrippedPath = previousId ? buildCollectionId(previousId, parentCollectionIds) : undefined;\n        const ref = doc(firestore, configPath, strippedPath);\n\n        console.debug(\"Updating collection\", {\n            id,\n            collectionData,\n            previousId,\n            parentCollectionIds,\n            cleanedCollection\n        });\n\n        return runTransaction(firestore, async (transaction) => {\n            transaction.set(ref, cleanedCollection, { merge: true });\n            if (previousStrippedPath && previousStrippedPath !== strippedPath) {\n                const previousRef = doc(firestore, configPath, previousStrippedPath);\n                transaction.delete(previousRef);\n            }\n        });\n    }, [configPath, firebaseApp, propertyConfigsMap]);\n\n    const collections = persistedCollections !== undefined ? applyPermissionsFunctionIfEmpty(persistedCollections, permissions as PermissionsBuilder<any, any>) : undefined;\n\n    const getCollection = useCallback((id: string) => {\n        if (!collections) throw Error(\"Collections not initialised\");\n        const collection = collections.find(c => c.id === id);\n        if (!collection) throw Error(`Collection with id ${id} not found`);\n        return collection;\n    }, [collections]);\n\n    const saveProperty = useCallback(({\n                                          path,\n                                          propertyKey,\n                                          property,\n                                          newPropertiesOrder,\n                                          parentCollectionIds,\n                                          namespace\n                                      }: {\n        path: string,\n        propertyKey: string,\n        property: Property,\n        newPropertiesOrder?: string[],\n        parentCollectionIds?: string[],\n        namespace?: string\n    }): Promise<void> => {\n\n        if (!firebaseApp || !configPath) throw Error(\"useFirestoreConfigurationPersistence Firestore not initialised\");\n        const firestore = getFirestore(firebaseApp);\n        const collectionPath = buildCollectionId(path, parentCollectionIds);\n        const ref = doc(firestore, configPath, collectionPath);\n        return runTransaction(firestore, async (transaction) => {\n            const data = {\n                [namespaceToPropertiesPath(namespace) + \".\" + propertyKey]: setUndefinedToDelete(removeFunctions(removeUndefined(property))),\n            };\n            if (newPropertiesOrder) {\n                data.propertiesOrder = newPropertiesOrder;\n            }\n            console.log(\"Saving property\", {\n                path,\n                propertyKey,\n                property,\n                collectionPath,\n                namespace,\n                data\n            });\n            transaction.update(ref, data);\n        });\n\n    }, [configPath, firebaseApp]);\n\n    const deleteProperty = useCallback(({\n                                            path,\n                                            propertyKey,\n                                            newPropertiesOrder,\n                                            parentCollectionIds,\n                                            namespace\n                                        }: {\n        path: string,\n        propertyKey: string,\n        newPropertiesOrder?: string[],\n        parentCollectionIds?: string[],\n        namespace?: string\n    }): Promise<void> => {\n\n        if (!firebaseApp || !configPath) throw Error(\"useFirestoreConfigurationPersistence Firestore not initialised\");\n        const firestore = getFirestore(firebaseApp);\n        const collectionPath = buildCollectionId(path, parentCollectionIds);\n        const ref = doc(firestore, configPath, collectionPath);\n        return runTransaction(firestore, async (transaction) => {\n            const data: any = setUndefinedToDelete({\n                [namespaceToPropertiesPath(namespace) + \".\" + propertyKey]: undefined,\n            });\n            if (newPropertiesOrder) {\n                data.propertiesOrder = newPropertiesOrder;\n            }\n            console.log(\"Deleting property\", {\n                path,\n                propertyKey,\n                collectionPath,\n                namespace,\n                data\n            });\n            transaction.update(ref, data);\n        });\n    }, [configPath, firebaseApp]);\n\n    return useMemo(() => ({\n        loading: collectionsLoading,\n        collections,\n        getCollection,\n        saveCollection,\n        updateCollection,\n        deleteCollection,\n        saveProperty,\n        deleteProperty,\n    }), [collectionsLoading, collections, getCollection, saveCollection, updateCollection, deleteCollection, saveProperty, deleteProperty])\n}\n"],"names":["useFirestoreCollectionsConfigController","firebaseApp","configPath","permissions","propertyConfigs","propertyConfigsMap","useMemo","map","field","collectionsLoading","setCollectionsLoading","React","persistedCollections","setPersistedCollections","collectionsError","setCollectionsError","useEffect","firestore","getFirestore","onSnapshot","collection","snapshot","newCollections","docsToCollectionTree","e","deleteCollection","useCallback","id","parentCollectionIds","collectionPath","buildCollectionId","ref","doc","deleteDoc","saveCollection","collectionData","previousId","cleanedCollection","prepareCollectionForPersistence","strippedPath","previousStrippedId","runTransaction","transaction","previousRef","updateCollection","previousStrippedPath","collections","applyPermissionsFunctionIfEmpty","getCollection","c","saveProperty","path","propertyKey","property","newPropertiesOrder","namespace","data","namespaceToPropertiesPath","setUndefinedToDelete","removeFunctions","removeUndefined","deleteProperty"],"mappings":"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"}