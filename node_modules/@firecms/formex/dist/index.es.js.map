{"version":3,"file":"index.es.js","sources":["../src/Formex.tsx","../src/utils.ts","../src/Field.tsx","../src/useCreateFormex.tsx"],"sourcesContent":["import React, { useContext } from \"react\";\nimport { FormexController } from \"./types\";\n\nconst FormexContext = React.createContext<FormexController<any>>({} as any);\n\nexport const useFormex = <T extends object>() => useContext<FormexController<T>>(FormexContext);\n\nexport const Formex = FormexContext.Provider;\n","import * as React from \"react\";\n\n/** @private is the value an empty array? */\nexport const isEmptyArray = (value?: any) =>\n    Array.isArray(value) && value.length === 0;\n\n/** @private is the given object a Function? */\nexport const isFunction = (obj: any): obj is Function =>\n    typeof obj === \"function\";\n\n/** @private is the given object an Object? */\nexport const isObject = (obj: any): obj is Object =>\n    obj !== null && typeof obj === \"object\";\n\n/** @private is the given object an integer? */\nexport const isInteger = (obj: any): boolean =>\n    String(Math.floor(Number(obj))) === obj;\n\n/** @private is the given object a string? */\nexport const isString = (obj: any): obj is string =>\n    Object.prototype.toString.call(obj) === \"[object String]\";\n\n/** @private is the given object a NaN? */\n// eslint-disable-next-line no-self-compare\nexport const isNaN = (obj: any): boolean => obj !== obj;\n\n/** @private Does a React component have exactly 0 children? */\nexport const isEmptyChildren = (children: any): boolean =>\n    React.Children.count(children) === 0;\n\n/** @private is the given object/value a promise? */\nexport const isPromise = (value: any): value is PromiseLike<any> =>\n    isObject(value) && isFunction(value.then);\n\n/** @private is the given object/value a type of synthetic event? */\nexport const isInputEvent = (value: any): value is React.SyntheticEvent<any> =>\n    value && isObject(value) && isObject(value.target);\n\n/**\n * Same as document.activeElement but wraps in a try-catch block. In IE it is\n * not safe to call document.activeElement if there is nothing focused.\n *\n * The activeElement will be null only if the document or document body is not\n * yet defined.\n *\n * @param {?Document} doc Defaults to current document.\n * @return {Element | null}\n * @see https://github.com/facebook/fbjs/blob/master/packages/fbjs/src/core/dom/getActiveElement.js\n */\nexport function getActiveElement(doc?: Document): Element | null {\n    doc = doc || (typeof document !== \"undefined\" ? document : undefined);\n    if (typeof doc === \"undefined\") {\n        return null;\n    }\n    try {\n        return doc.activeElement || doc.body;\n    } catch (e) {\n        return doc.body;\n    }\n}\n\n/**\n * Deeply get a value from an object via its path.\n */\nexport function getIn(\n    obj: any,\n    key: string | string[],\n    def?: any,\n    p = 0\n) {\n    const path = toPath(key);\n    while (obj && p < path.length) {\n        obj = obj[path[p++]];\n    }\n\n    // check if path is not in the end\n    if (p !== path.length && !obj) {\n        return def;\n    }\n\n    return obj === undefined ? def : obj;\n}\n\nexport function setIn(obj: any, path: string, value: any): any {\n    const res: any = clone(obj); // this keeps inheritance when obj is a class\n    let resVal: any = res;\n    let i = 0;\n    const pathArray = toPath(path);\n\n    for (; i < pathArray.length - 1; i++) {\n        const currentPath: string = pathArray[i];\n        const currentObj: any = getIn(obj, pathArray.slice(0, i + 1));\n\n        if (currentObj && (isObject(currentObj) || Array.isArray(currentObj))) {\n            resVal = resVal[currentPath] = clone(currentObj);\n        } else {\n            const nextPath: string = pathArray[i + 1];\n            resVal = resVal[currentPath] =\n                isInteger(nextPath) && Number(nextPath) >= 0 ? [] : {};\n        }\n    }\n\n    // Return original object if new value is the same as current\n    if ((i === 0 ? obj : resVal)[pathArray[i]] === value) {\n        return obj;\n    }\n\n    if (value === undefined) {\n        delete resVal[pathArray[i]];\n    } else {\n        resVal[pathArray[i]] = value;\n    }\n\n    // If the path array has a single element, the loop did not run.\n    // Deleting on `resVal` had no effect in this scenario, so we delete on the result instead.\n    if (i === 0 && value === undefined) {\n        delete res[pathArray[i]];\n    }\n\n    return res;\n}\n\n/**\n * Recursively a set the same value for all keys and arrays nested object, cloning\n * @param object\n * @param value\n * @param visited\n * @param response\n */\nexport function setNestedObjectValues<T>(\n    object: any,\n    value: any,\n    visited: any = new WeakMap(),\n    response: any = {}\n): T {\n    for (const k of Object.keys(object)) {\n        const val = object[k];\n        if (isObject(val)) {\n            if (!visited.get(val)) {\n                visited.set(val, true);\n                // In order to keep array values consistent for both dot path  and\n                // bracket syntax, we need to check if this is an array so that\n                // this will output  { friends: [true] } and not { friends: { \"0\": true } }\n                response[k] = Array.isArray(val) ? [] : {};\n                setNestedObjectValues(val, value, visited, response[k]);\n            }\n        } else {\n            response[k] = value;\n        }\n    }\n\n    return response;\n}\n\nfunction clone(value: any) {\n    if (Array.isArray(value)) {\n        return [...value];\n    } else if (typeof value === \"object\" && value !== null) {\n        return { ...value };\n    } else {\n        return value; // This is for primitive types which do not need cloning.\n    }\n}\n\nfunction toPath(value: string | string[]) {\n    if (Array.isArray(value)) return value; // Already in path array form.\n    // Replace brackets with dots, remove leading/trailing dots, then split by dot.\n    return value.replace(/\\[(\\d+)]/g, \".$1\").replace(/^\\./, \"\").replace(/\\.$/, \"\").split(\".\");\n}\n","import * as React from \"react\";\nimport { useFormex } from \"./Formex\";\nimport { getIn, isFunction, isObject } from \"./utils\";\nimport { FormexController } from \"./types\";\n\nexport interface FieldInputProps<Value> {\n    /** Value of the field */\n    value: Value;\n    /** Name of the field */\n    name: string;\n    /** Multiple select? */\n    multiple?: boolean;\n    /** Is the field checked? */\n    checked?: boolean;\n    /** Change event handler */\n    onChange: (event: React.SyntheticEvent) => void,\n    /** Blur event handler */\n    onBlur: (event: React.FocusEvent) => void,\n}\n\nexport interface FormexFieldProps<Value = any, FormValues extends object = any> {\n    field: FieldInputProps<Value>;\n    form: FormexController<FormValues>;\n}\n\nexport type FieldValidator = (\n    value: any\n) => string | void | Promise<string | void>;\n\nexport interface FieldConfig<Value, C extends React.ElementType | undefined = undefined> {\n\n    /**\n     * Component to render. Can either be a string e.g. 'select', 'input', or 'textarea', or a component.\n     */\n    as?:\n        | C\n        | string\n        | React.ForwardRefExoticComponent<any>;\n\n    /**\n     * Children render function <Field name>{props => ...}</Field>)\n     */\n    children?: ((props: FormexFieldProps<Value>) => React.ReactNode) | React.ReactNode;\n\n    /**\n     * Validate a single field value independently\n     */\n    // validate?: FieldValidator;\n\n    /**\n     * Used for 'select' and related input types.\n     */\n    multiple?: boolean;\n\n    /**\n     * Field name\n     */\n    name: string;\n\n    /** HTML input type */\n    type?: string;\n\n    /** Field value */\n    value?: any;\n\n    /** Inner ref */\n    innerRef?: (instance: any) => void;\n\n}\n\nexport type FieldProps<T, C extends React.ElementType | undefined> = {\n    as?: C;\n} & (C extends React.ElementType ? (React.ComponentProps<C> & FieldConfig<T, C>) : FieldConfig<T, C>);\n\nexport function Field<T, C extends React.ElementType | undefined = undefined>({\n                                                                                  validate,\n                                                                                  name,\n                                                                                  children,\n                                                                                  as: is, // `as` is reserved in typescript lol\n                                                                                  // component,\n                                                                                  className,\n                                                                                  ...props\n                                                                              }: FieldProps<T, C>) {\n    const formex = useFormex();\n\n    const field = getFieldProps({ name, ...props }, formex);\n\n    if (isFunction(children)) {\n        return children({ field, form: formex });\n    }\n\n    // if (component) {\n    //     if (typeof component === \"string\") {\n    //         const { innerRef, ...rest } = props;\n    //         return React.createElement(\n    //             component,\n    //             { ref: innerRef, ...field, ...rest, className },\n    //             children\n    //         );\n    //     }\n    //     return React.createElement(\n    //         component,\n    //         { field, form: formex, ...props, className },\n    //         children\n    //     );\n    // }\n\n    // default to input here so we can check for both `as` and `children` above\n    const asElement = is || \"input\";\n\n    if (typeof asElement === \"string\") {\n        const { innerRef, ...rest } = props;\n        return React.createElement(\n            asElement,\n            { ref: innerRef, ...field, ...rest, className },\n            children\n        );\n    }\n\n    return React.createElement(asElement, { ...field, ...props, className }, children);\n}\n\nconst getFieldProps = (nameOrOptions: string | FieldConfig<any>, formex: FormexController<any>): FieldInputProps<any> => {\n    const isAnObject = isObject(nameOrOptions);\n    const name = isAnObject\n        ? (nameOrOptions as FieldConfig<any>).name\n        : nameOrOptions;\n    const valueState = getIn(formex.values, name);\n\n    const field: FieldInputProps<any> = {\n        name,\n        value: valueState,\n        onChange: formex.handleChange,\n        onBlur: formex.handleBlur,\n    };\n    if (isAnObject) {\n        const {\n            type,\n            value: valueProp, // value is special for checkboxes\n            as: is,\n            multiple,\n        } = nameOrOptions as FieldConfig<any>;\n\n        if (type === \"checkbox\") {\n            if (valueProp === undefined) {\n                field.checked = !!valueState;\n            } else {\n                field.checked = !!(\n                    Array.isArray(valueState) && ~valueState.indexOf(valueProp)\n                );\n                field.value = valueProp;\n            }\n        } else if (type === \"radio\") {\n            field.checked = valueState === valueProp;\n            field.value = valueProp;\n        } else if (is === \"select\" && multiple) {\n            field.value = field.value || [];\n            field.multiple = true;\n        }\n    }\n    return field;\n};\n","import React, { FormEvent, useEffect, useState } from \"react\";\nimport { getIn, setIn } from \"./utils\";\nimport equal from \"react-fast-compare\"\n\nimport { FormexController, FormexResetProps } from \"./types\";\n\nexport function useCreateFormex<T extends object>({ initialValues, initialErrors, validation, validateOnChange = false, onSubmit, validateOnInitialRender = false }: {\n    initialValues: T,\n    initialErrors?: Record<string, string>,\n    validateOnChange?: boolean,\n    validateOnInitialRender?: boolean,\n    validation?: (values: T) => Record<string, string> | Promise<Record<string, string>> | undefined | void,\n    onSubmit?: (values: T, controller: FormexController<T>) => void | Promise<void>\n}): FormexController<T> {\n\n    const initialValuesRef = React.useRef<T>(initialValues);\n    const valuesRef = React.useRef<T>(initialValues);\n\n    const [values, setValuesInner] = useState<T>(initialValues);\n    const [touchedState, setTouchedState] = useState<Record<string, boolean>>({});\n    const [errors, setErrors] = useState<Record<string, string>>(initialErrors ?? {});\n    const [dirty, setDirty] = useState(false);\n    const [submitCount, setSubmitCount] = useState(0);\n    const [isSubmitting, setIsSubmitting] = useState(false);\n    const [isValidating, setIsValidating] = useState(false);\n\n    useEffect(() => {\n        if (validateOnInitialRender) {\n            validate();\n        }\n    }, []);\n\n    const setValues = (newValues: T) => {\n        valuesRef.current = newValues;\n        setValuesInner(newValues);\n        setDirty(equal(initialValuesRef.current, newValues));\n    }\n\n    const validate = async () => {\n        setIsValidating(true);\n        const values = valuesRef.current;\n        const validationErrors = await validation?.(values);\n        setErrors(validationErrors ?? {});\n        setIsValidating(false);\n        return validationErrors;\n    }\n\n    const setFieldValue = (key: string, value: any, shouldValidate?: boolean) => {\n        const newValues = setIn(valuesRef.current, key, value);\n        valuesRef.current = newValues;\n        setValuesInner(newValues);\n        if (!equal(getIn(initialValuesRef.current, key), value)) {\n            setDirty(true);\n        }\n        if (shouldValidate) {\n            validate();\n        }\n    }\n\n    const setFieldError = (key: string, error: string | undefined) => {\n        const newErrors = { ...errors };\n        if (error) {\n            newErrors[key] = error;\n        } else {\n            delete newErrors[key];\n        }\n        setErrors(newErrors);\n    }\n\n    const setFieldTouched = (key: string, touched: boolean, shouldValidate?: boolean | undefined) => {\n        const newTouched = { ...touchedState };\n        newTouched[key] = touched;\n        setTouchedState(newTouched);\n        if (shouldValidate) {\n            validate();\n        }\n    }\n\n    const handleChange = (event: React.SyntheticEvent) => {\n        const target = event.target as HTMLInputElement;\n        const value = target.type === \"checkbox\" ? target.checked : target.value;\n        const name = target.name;\n        setFieldValue(name, value, validateOnChange);\n        setFieldTouched(name, true);\n    }\n\n    const handleBlur = (event: React.FocusEvent) => {\n        const target = event.target as HTMLInputElement;\n        const name = target.name;\n        setFieldTouched(name, true);\n    }\n\n    const submit = async (e?: FormEvent<HTMLFormElement>) => {\n        e?.preventDefault();\n        e?.stopPropagation();\n        setIsSubmitting(true);\n        setSubmitCount(submitCount + 1);\n        const validationErrors = await validation?.(valuesRef.current);\n        if (validationErrors && Object.keys(validationErrors).length > 0) {\n            setErrors(validationErrors);\n        } else {\n            setErrors({});\n            await onSubmit?.(valuesRef.current, controllerRef.current);\n        }\n        setIsSubmitting(false);\n    }\n\n    const resetForm = (props?: FormexResetProps<T>) => {\n        const {\n            submitCount: submitCountProp,\n            values: valuesProp,\n            errors: errorsProp,\n            touched: touchedProp\n        } = props ?? {};\n        initialValuesRef.current = valuesProp ?? initialValues;\n        valuesRef.current = valuesProp ?? initialValues;\n        setValuesInner(valuesProp ?? initialValues);\n        setErrors(errorsProp ?? {});\n        setTouchedState(touchedProp ?? {});\n        setDirty(false);\n        setSubmitCount(submitCountProp ?? 0);\n    }\n\n    const controller: FormexController<T> = {\n        values,\n        initialValues: initialValuesRef.current,\n        handleChange,\n        isSubmitting,\n        setSubmitting: setIsSubmitting,\n        setValues,\n        setFieldValue,\n        errors,\n        setFieldError,\n        touched: touchedState,\n        setFieldTouched,\n        dirty,\n        setDirty,\n        handleSubmit: submit,\n        submitCount,\n        setSubmitCount,\n        handleBlur,\n        validate,\n        isValidating,\n        resetForm\n    };\n\n    const controllerRef = React.useRef<FormexController<T>>(controller);\n    controllerRef.current = controller;\n    return controller\n}\n"],"names":["FormexContext","React","useFormex","useContext","Formex","isEmptyArray","value","isFunction","obj","isObject","isInteger","isString","isNaN","isEmptyChildren","children","isPromise","isInputEvent","getActiveElement","doc","getIn","key","def","p","path","toPath","setIn","res","clone","resVal","i","pathArray","currentPath","currentObj","nextPath","setNestedObjectValues","object","visited","response","k","val","Field","validate","name","is","className","props","formex","field","getFieldProps","asElement","innerRef","rest","nameOrOptions","isAnObject","valueState","type","valueProp","multiple","useCreateFormex","initialValues","initialErrors","validation","validateOnChange","onSubmit","validateOnInitialRender","initialValuesRef","valuesRef","values","setValuesInner","useState","touchedState","setTouchedState","errors","setErrors","dirty","setDirty","submitCount","setSubmitCount","isSubmitting","setIsSubmitting","isValidating","setIsValidating","useEffect","setValues","newValues","equal","validationErrors","setFieldValue","shouldValidate","setFieldError","error","newErrors","setFieldTouched","touched","newTouched","handleChange","event","target","handleBlur","submit","e","controllerRef","resetForm","submitCountProp","valuesProp","errorsProp","touchedProp","controller"],"mappings":";;;AAGA,MAAMA,IAAgBC,EAAM,cAAqC,CAAA,CAAS,GAE7DC,IAAY,MAAwBC,EAAgCH,CAAa,GAEjFI,KAASJ,EAAc,UCJvBK,KAAe,CAACC,MACzB,MAAM,QAAQA,CAAK,KAAKA,EAAM,WAAW,GAGhCC,IAAa,CAACC,MACvB,OAAOA,KAAQ,YAGNC,IAAW,CAACD,MACrBA,MAAQ,QAAQ,OAAOA,KAAQ,UAGtBE,IAAY,CAACF,MACtB,OAAO,KAAK,MAAM,OAAOA,CAAG,CAAC,CAAC,MAAMA,GAG3BG,KAAW,CAACH,MACrB,OAAO,UAAU,SAAS,KAAKA,CAAG,MAAM,mBAI/BI,KAAQ,CAACJ,MAAsBA,MAAQA,GAGvCK,KAAkB,CAACC,MAC5Bb,EAAM,SAAS,MAAMa,CAAQ,MAAM,GAG1BC,KAAY,CAACT,MACtBG,EAASH,CAAK,KAAKC,EAAWD,EAAM,IAAI,GAG/BU,KAAe,CAACV,MACzBA,KAASG,EAASH,CAAK,KAAKG,EAASH,EAAM,MAAM;AAa9C,SAASW,GAAiBC,GAAgC;AAEzD,MADJA,IAAMA,MAAQ,OAAO,WAAa,MAAc,WAAW,SACvD,OAAOA,IAAQ;AACR,WAAA;AAEP,MAAA;AACO,WAAAA,EAAI,iBAAiBA,EAAI;AAAA,UACxB;AACR,WAAOA,EAAI;AAAA,EACf;AACJ;AAKO,SAASC,EACZX,GACAY,GACAC,GACAC,IAAI,GACN;AACQ,QAAAC,IAAOC,EAAOJ,CAAG;AAChB,SAAAZ,KAAOc,IAAIC,EAAK;AACb,IAAAf,IAAAA,EAAIe,EAAKD,GAAG,CAAC;AAIvB,SAAIA,MAAMC,EAAK,UAAU,CAACf,KAInBA,MAAQ,SAHJa,IAGsBb;AACrC;AAEgB,SAAAiB,EAAMjB,GAAUe,GAAcjB,GAAiB;AACrD,QAAAoB,IAAWC,EAAMnB,CAAG;AAC1B,MAAIoB,IAAcF,GACdG,IAAI;AACF,QAAAC,IAAYN,EAAOD,CAAI;AAE7B,SAAOM,IAAIC,EAAU,SAAS,GAAGD,KAAK;AAC5B,UAAAE,IAAsBD,EAAUD,CAAC,GACjCG,IAAkBb,EAAMX,GAAKsB,EAAU,MAAM,GAAGD,IAAI,CAAC,CAAC;AAE5D,QAAIG,MAAevB,EAASuB,CAAU,KAAK,MAAM,QAAQA,CAAU;AAC/D,MAAAJ,IAASA,EAAOG,CAAW,IAAIJ,EAAMK,CAAU;AAAA,SAC5C;AACG,YAAAC,IAAmBH,EAAUD,IAAI,CAAC;AACxC,MAAAD,IAASA,EAAOG,CAAW,IACvBrB,EAAUuB,CAAQ,KAAK,OAAOA,CAAQ,KAAK,IAAI,CAAA,IAAK,CAAA;AAAA,IAC5D;AAAA,EACJ;AAGK,UAAAJ,MAAM,IAAIrB,IAAMoB,GAAQE,EAAUD,CAAC,CAAC,MAAMvB,IACpCE,KAGPF,MAAU,SACH,OAAAsB,EAAOE,EAAUD,CAAC,CAAC,IAEnBD,EAAAE,EAAUD,CAAC,CAAC,IAAIvB,GAKvBuB,MAAM,KAAKvB,MAAU,UACd,OAAAoB,EAAII,EAAUD,CAAC,CAAC,GAGpBH;AACX;AASgB,SAAAQ,EACZC,GACA7B,GACA8B,wBAAmB,QAAQ,GAC3BC,IAAgB,IACf;AACD,aAAWC,KAAK,OAAO,KAAKH,CAAM,GAAG;AAC3B,UAAAI,IAAMJ,EAAOG,CAAC;AAChB,IAAA7B,EAAS8B,CAAG,IACPH,EAAQ,IAAIG,CAAG,MACRH,EAAA,IAAIG,GAAK,EAAI,GAIZF,EAAAC,CAAC,IAAI,MAAM,QAAQC,CAAG,IAAI,KAAK,IACxCL,EAAsBK,GAAKjC,GAAO8B,GAASC,EAASC,CAAC,CAAC,KAG1DD,EAASC,CAAC,IAAIhC;AAAA,EAEtB;AAEO,SAAA+B;AACX;AAEA,SAASV,EAAMrB,GAAY;AACnB,SAAA,MAAM,QAAQA,CAAK,IACZ,CAAC,GAAGA,CAAK,IACT,OAAOA,KAAU,YAAYA,MAAU,OACvC,EAAE,GAAGA,MAELA;AAEf;AAEA,SAASkB,EAAOlB,GAA0B;AAClC,SAAA,MAAM,QAAQA,CAAK,IAAUA,IAE1BA,EAAM,QAAQ,aAAa,KAAK,EAAE,QAAQ,OAAO,EAAE,EAAE,QAAQ,OAAO,EAAE,EAAE,MAAM,GAAG;AAC5F;AC9FO,SAASkC,GAA8D;AAAA,EACI,UAAAC;AAAA,EACA,MAAAC;AAAA,EACA,UAAA5B;AAAA,EACA,IAAI6B;AAAA;AAAA;AAAA,EAEJ,WAAAC;AAAA,EACA,GAAGC;AACP,GAAqB;AAC/F,QAAMC,IAAS5C,KAET6C,IAAQC,GAAc,EAAE,MAAAN,GAAM,GAAGG,EAAA,GAASC,CAAM;AAElD,MAAAvC,EAAWO,CAAQ;AACnB,WAAOA,EAAS,EAAE,OAAAiC,GAAO,MAAMD,EAAQ,CAAA;AAoB3C,QAAMG,IAAYN,KAAM;AAEpB,MAAA,OAAOM,KAAc,UAAU;AAC/B,UAAM,EAAE,UAAAC,GAAU,GAAGC,EAAA,IAASN;AAC9B,WAAO5C,EAAM;AAAA,MACTgD;AAAA,MACA,EAAE,KAAKC,GAAU,GAAGH,GAAO,GAAGI,GAAM,WAAAP,EAAU;AAAA,MAC9C9B;AAAA,IAAA;AAAA,EAER;AAEO,SAAAb,EAAM,cAAcgD,GAAW,EAAE,GAAGF,GAAO,GAAGF,GAAO,WAAAD,KAAa9B,CAAQ;AACrF;AAEA,MAAMkC,KAAgB,CAACI,GAA0CN,MAAwD;AAC/G,QAAAO,IAAa5C,EAAS2C,CAAa,GACnCV,IAAOW,IACND,EAAmC,OACpCA,GACAE,IAAanC,EAAM2B,EAAO,QAAQJ,CAAI,GAEtCK,IAA8B;AAAA,IAChC,MAAAL;AAAA,IACA,OAAOY;AAAA,IACP,UAAUR,EAAO;AAAA,IACjB,QAAQA,EAAO;AAAA,EAAA;AAEnB,MAAIO,GAAY;AACN,UAAA;AAAA,MACF,MAAAE;AAAA,MACA,OAAOC;AAAA;AAAA,MACP,IAAIb;AAAA,MACJ,UAAAc;AAAA,IACA,IAAAL;AAEJ,IAAIG,MAAS,aACLC,MAAc,SACRT,EAAA,UAAU,CAAC,CAACO,KAEZP,EAAA,UAAU,CAAC,EACb,MAAM,QAAQO,CAAU,KAAK,CAACA,EAAW,QAAQE,CAAS,IAE9DT,EAAM,QAAQS,KAEXD,MAAS,WAChBR,EAAM,UAAUO,MAAeE,GAC/BT,EAAM,QAAQS,KACPb,MAAO,YAAYc,MACpBV,EAAA,QAAQA,EAAM,SAAS,CAAA,GAC7BA,EAAM,WAAW;AAAA,EAEzB;AACO,SAAAA;AACX;AC3JgB,SAAAW,GAAkC,EAAE,eAAAC,GAAe,eAAAC,GAAe,YAAAC,GAAY,kBAAAC,IAAmB,IAAO,UAAAC,GAAU,yBAAAC,IAA0B,MAOpI;AAEd,QAAAC,IAAmBhE,EAAM,OAAU0D,CAAa,GAChDO,IAAYjE,EAAM,OAAU0D,CAAa,GAEzC,CAACQ,GAAQC,CAAc,IAAIC,EAAYV,CAAa,GACpD,CAACW,GAAcC,CAAe,IAAIF,EAAkC,CAAE,CAAA,GACtE,CAACG,GAAQC,CAAS,IAAIJ,EAAiCT,KAAiB,CAAA,CAAE,GAC1E,CAACc,GAAOC,CAAQ,IAAIN,EAAS,EAAK,GAClC,CAACO,GAAaC,CAAc,IAAIR,EAAS,CAAC,GAC1C,CAACS,GAAcC,CAAe,IAAIV,EAAS,EAAK,GAChD,CAACW,GAAcC,CAAe,IAAIZ,EAAS,EAAK;AAEtD,EAAAa,EAAU,MAAM;AACZ,IAAIlB,KACSvB;EAEjB,GAAG,CAAE,CAAA;AAEC,QAAA0C,IAAY,CAACC,MAAiB;AAChC,IAAAlB,EAAU,UAAUkB,GACpBhB,EAAegB,CAAS,GACxBT,EAASU,EAAMpB,EAAiB,SAASmB,CAAS,CAAC;AAAA,EAAA,GAGjD3C,IAAW,YAAY;AACzB,IAAAwC,EAAgB,EAAI;AACpB,UAAMd,IAASD,EAAU,SACnBoB,IAAmB,MAAMzB,IAAaM,CAAM;AACxC,WAAAM,EAAAa,KAAoB,CAAA,CAAE,GAChCL,EAAgB,EAAK,GACdK;AAAA,EAAA,GAGLC,IAAgB,CAACnE,GAAad,GAAYkF,MAA6B;AACzE,UAAMJ,IAAY3D,EAAMyC,EAAU,SAAS9C,GAAKd,CAAK;AACrD,IAAA4D,EAAU,UAAUkB,GACpBhB,EAAegB,CAAS,GACnBC,EAAMlE,EAAM8C,EAAiB,SAAS7C,CAAG,GAAGd,CAAK,KAClDqE,EAAS,EAAI,GAEba,KACS/C;EACb,GAGEgD,IAAgB,CAACrE,GAAasE,MAA8B;AACxD,UAAAC,IAAY,EAAE,GAAGnB;AACvB,IAAIkB,IACAC,EAAUvE,CAAG,IAAIsE,IAEjB,OAAOC,EAAUvE,CAAG,GAExBqD,EAAUkB,CAAS;AAAA,EAAA,GAGjBC,IAAkB,CAACxE,GAAayE,GAAkBL,MAAyC;AACvF,UAAAM,IAAa,EAAE,GAAGxB;AACxB,IAAAwB,EAAW1E,CAAG,IAAIyE,GAClBtB,EAAgBuB,CAAU,GACtBN,KACS/C;EACb,GAGEsD,IAAe,CAACC,MAAgC;AAClD,UAAMC,IAASD,EAAM,QACf1F,IAAQ2F,EAAO,SAAS,aAAaA,EAAO,UAAUA,EAAO,OAC7DvD,IAAOuD,EAAO;AACN,IAAAV,EAAA7C,GAAMpC,GAAOwD,CAAgB,GAC3C8B,EAAgBlD,GAAM,EAAI;AAAA,EAAA,GAGxBwD,IAAa,CAACF,MAA4B;AAE5C,UAAMtD,IADSsD,EAAM,OACD;AACpB,IAAAJ,EAAgBlD,GAAM,EAAI;AAAA,EAAA,GAGxByD,IAAS,OAAOC,MAAmC;AACrD,IAAAA,GAAG,eAAe,GAClBA,GAAG,gBAAgB,GACnBrB,EAAgB,EAAI,GACpBF,EAAeD,IAAc,CAAC;AAC9B,UAAMU,IAAmB,MAAMzB,IAAaK,EAAU,OAAO;AAC7D,IAAIoB,KAAoB,OAAO,KAAKA,CAAgB,EAAE,SAAS,IAC3Db,EAAUa,CAAgB,KAE1Bb,EAAU,CAAE,CAAA,GACZ,MAAMV,IAAWG,EAAU,SAASmC,EAAc,OAAO,IAE7DtB,EAAgB,EAAK;AAAA,EAAA,GAGnBuB,IAAY,CAACzD,MAAgC;AACzC,UAAA;AAAA,MACF,aAAa0D;AAAA,MACb,QAAQC;AAAA,MACR,QAAQC;AAAA,MACR,SAASC;AAAA,IAAA,IACT7D,KAAS,CAAA;AACb,IAAAoB,EAAiB,UAAUuC,KAAc7C,GACzCO,EAAU,UAAUsC,KAAc7C,GAClCS,EAAeoC,KAAc7C,CAAa,GAChCc,EAAAgC,KAAc,CAAA,CAAE,GACVlC,EAAAmC,KAAe,CAAA,CAAE,GACjC/B,EAAS,EAAK,GACdE,EAAe0B,KAAmB,CAAC;AAAA,EAAA,GAGjCI,IAAkC;AAAA,IACpC,QAAAxC;AAAA,IACA,eAAeF,EAAiB;AAAA,IAChC,cAAA8B;AAAA,IACA,cAAAjB;AAAA,IACA,eAAeC;AAAA,IACf,WAAAI;AAAA,IACA,eAAAI;AAAA,IACA,QAAAf;AAAA,IACA,eAAAiB;AAAA,IACA,SAASnB;AAAA,IACT,iBAAAsB;AAAA,IACA,OAAAlB;AAAA,IACA,UAAAC;AAAA,IACA,cAAcwB;AAAA,IACd,aAAAvB;AAAA,IACA,gBAAAC;AAAA,IACA,YAAAqB;AAAA,IACA,UAAAzD;AAAA,IACA,cAAAuC;AAAA,IACA,WAAAsB;AAAA,EAAA,GAGED,IAAgBpG,EAAM,OAA4B0G,CAAU;AAClE,SAAAN,EAAc,UAAUM,GACjBA;AACX;"}