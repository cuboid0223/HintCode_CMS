{"version":3,"file":"index.umd.js","sources":["../src/strings.ts","../src/util.ts","../src/builders/string_property_builder.ts","../src/builders/validation_builder.ts","../src/builders/reference_property_builder.ts","../src/collection_builder.ts"],"sourcesContent":["import { ValuesCountEntry } from \"./types\";\nimport { DocumentReference } from \"firebase/firestore\";\n\nexport function findCommonInitialStringInPath(valuesCount?: ValuesCountEntry) {\n\n    if (!valuesCount) return undefined;\n\n    function getPath(value: any) {\n        if (typeof value === \"string\") return value;\n        else if (value instanceof DocumentReference) return value.path;\n        else return undefined;\n    }\n\n    const strings: string[] = valuesCount.values.map((v) => getPath(v)).filter(v => !!v) as string[];\n    const pathWithSlash = strings.find((s) => s.includes(\"/\"));\n    if (!pathWithSlash)\n        return undefined;\n\n    const searchedPath = pathWithSlash.substr(0, pathWithSlash.lastIndexOf(\"/\"));\n\n    const yep = valuesCount.values\n        .filter((value) => {\n            const path = getPath(value);\n            if (!path) return false;\n            return path.startsWith(searchedPath)\n        }).length > valuesCount.values.length / 3 * 2;\n\n    return yep ? searchedPath : undefined;\n\n}\n\nexport function removeInitialAndTrailingSlashes(s: string): string {\n    return removeInitialSlash(removeTrailingSlash(s));\n}\n\nexport function removeInitialSlash(s: string) {\n    if (s.startsWith(\"/\"))\n        return s.slice(1);\n    else return s;\n}\n\nexport function removeTrailingSlash(s: string) {\n    if (s.endsWith(\"/\"))\n        return s.slice(0, -1);\n    else return s;\n}\n","import { unslugify } from \"@firecms/core\";\n\nexport function extractEnumFromValues(values: unknown[]) {\n    if (!Array.isArray(values)) {\n        return [];\n    }\n    const enumValues = values\n        .map((value) => {\n            if (typeof value === \"string\") {\n                return ({ id: value, label: unslugify(value) });\n            } else\n                return null;\n        }).filter(Boolean) as Array<{ id: string, label: string }>;\n    enumValues.sort((a, b) => a.label.localeCompare(b.label));\n    return enumValues;\n}\n","import { FileType, Property, StringProperty } from \"@firecms/core\";\nimport { InferencePropertyBuilderProps, ValuesCountEntry } from \"../types\";\nimport { findCommonInitialStringInPath } from \"../strings\";\nimport { extractEnumFromValues } from \"../util\";\n\nconst IMAGE_EXTENSIONS = [\".jpg\", \".png\", \".webp\", \".gif\"];\nconst AUDIO_EXTENSIONS = [\".mp3\", \".ogg\", \".opus\", \".aac\"];\nconst VIDEO_EXTENSIONS = [\".avi\", \".mp4\"];\n\nconst emailRegEx = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n\n\nexport function buildStringProperty({\n                                        totalDocsCount,\n                                        valuesResult\n                                    }: InferencePropertyBuilderProps): Property {\n\n    let stringProperty: Property = {\n        dataType: \"string\",\n\n    };\n\n    if (valuesResult) {\n\n        const totalEntriesCount = valuesResult.values.length;\n        const totalValues = Array.from(valuesResult.valuesCount.keys()).length;\n\n        const config: Partial<StringProperty> = {};\n\n        const probablyAURL = valuesResult.values\n            .filter((value) => typeof value === \"string\" &&\n                value.toString().startsWith(\"http\")).length > totalDocsCount / 3 * 2;\n        if (probablyAURL) {\n            config.url = true;\n        }\n\n        const probablyAnEmail = valuesResult.values\n            .filter((value) => typeof value === \"string\" &&\n                emailRegEx.test(value)).length > totalDocsCount / 3 * 2;\n        if (probablyAnEmail) {\n            config.email = true;\n        }\n\n        const probablyUserIds = valuesResult.values\n            .filter((value) => typeof value === \"string\" && value.length === 28 && !value.includes(\" \"))\n            .length > totalDocsCount / 3 * 2;\n        if (probablyUserIds)\n            config.readOnly = true;\n\n        if (!probablyAnEmail &&\n            !probablyAURL &&\n            !probablyUserIds &&\n            !probablyAURL &&\n            totalValues < totalEntriesCount / 3\n        ) {\n            const enumValues = extractEnumFromValues(Array.from(valuesResult.valuesCount.keys()));\n\n            if (Object.keys(enumValues).length > 1)\n                config.enumValues = enumValues;\n        }\n\n        // regular string\n        if (!probablyAnEmail &&\n            !probablyAURL &&\n            !probablyUserIds &&\n            !probablyAURL &&\n            !config.enumValues) {\n            const fileType = probableFileType(valuesResult, totalDocsCount);\n            if (fileType) {\n                config.storage = {\n                    acceptedFiles: [fileType as FileType],\n                    storagePath: findCommonInitialStringInPath(valuesResult) ?? \"/\"\n                };\n            }\n        }\n\n        if (Object.keys(config).length > 0)\n            stringProperty = {\n                ...stringProperty,\n                ...config,\n                editable: true\n            };\n    }\n\n    return stringProperty;\n}\n\n// TODO: support returning multiple types\nfunction probableFileType(valuesCount: ValuesCountEntry, totalDocsCount: number): boolean | FileType {\n    const probablyAnImage = valuesCount.values\n        .filter((value) => typeof value === \"string\" &&\n            IMAGE_EXTENSIONS.some((extension) => value.toString().endsWith(extension))).length > totalDocsCount / 3 * 2;\n\n    const probablyAudio = valuesCount.values\n        .filter((value) => typeof value === \"string\" &&\n            AUDIO_EXTENSIONS.some((extension) => value.toString().endsWith(extension))).length > totalDocsCount / 3 * 2;\n\n    const probablyVideo = valuesCount.values\n        .filter((value) => typeof value === \"string\" &&\n            VIDEO_EXTENSIONS.some((extension) => value.toString().endsWith(extension))).length > totalDocsCount / 3 * 2;\n\n    const fileType: boolean | FileType = probablyAnImage\n        ? \"image/*\"\n        : probablyAudio\n            ? \"audio/*\"\n            : probablyVideo ? \"video/*\" : false;\n    return fileType;\n}\n","import { PropertyValidationSchema } from \"@firecms/core\";\nimport { InferencePropertyBuilderProps } from \"../types\";\n\nexport function buildValidation({\n                                    totalDocsCount,\n                                    valuesResult\n                                }: InferencePropertyBuilderProps): PropertyValidationSchema | undefined {\n\n    if (valuesResult) {\n        const totalEntriesCount = valuesResult.values.length;\n        if (totalDocsCount === totalEntriesCount)\n            return {\n                required: true\n            }\n    }\n\n    return undefined;\n}\n","import { InferencePropertyBuilderProps } from \"../types\";\nimport { findCommonInitialStringInPath } from \"../strings\";\nimport { Property } from \"@firecms/core\";\n\nexport function buildReferenceProperty({\n                                        totalDocsCount,\n                                        valuesResult\n                                    }: InferencePropertyBuilderProps): Property {\n\n    const property: Property = {\n        dataType: \"reference\",\n        path: findCommonInitialStringInPath(valuesResult) ?? \"!!!FIX_ME!!!\",\n        editable: true\n    };\n\n    return property;\n}\n","import {\n    DataType,\n    EnumValues,\n    mergeDeep,\n    Properties,\n    Property,\n    resolveEnumValues,\n    StringProperty\n} from \"@firecms/core\";\nimport {\n    InferencePropertyBuilderProps,\n    TypesCount,\n    TypesCountRecord,\n    ValuesCountEntry,\n    ValuesCountRecord\n} from \"./types\";\nimport { buildStringProperty } from \"./builders/string_property_builder\";\nimport { buildValidation } from \"./builders/validation_builder\";\nimport { buildReferenceProperty } from \"./builders/reference_property_builder\";\nimport { extractEnumFromValues } from \"./util\";\n\nexport type InferenceTypeBuilder = (value: any) => DataType;\n\nexport async function buildEntityPropertiesFromData(data: object[], getType: InferenceTypeBuilder): Promise<Properties> {\n    const typesCount: TypesCountRecord = {};\n    const valuesCount: ValuesCountRecord = {};\n    if (data) {\n        data.forEach((entry) => {\n            if (entry) {\n                Object.entries(entry).forEach(([key, value]) => {\n                    increaseMapTypeCount(typesCount, key, value, getType);\n                    increaseValuesCount(valuesCount, key, value, getType);\n                })\n            }\n        });\n    }\n    // console.log(util.inspect({ typesCount }, { showHidden: false, depth: null, colors: true }));\n    return buildPropertiesFromCount(data.length, typesCount, valuesCount);\n}\n\nexport function buildPropertyFromData(data: any[], property: Property, getType: InferenceTypeBuilder): Property {\n    const typesCount = {};\n    const valuesCount: ValuesCountRecord = {};\n    if (data) {\n        data.forEach((entry) => {\n            increaseTypeCount(property.dataType, typesCount, entry, getType);\n            increaseValuesCount(valuesCount, \"inferred_prop\", entry, getType);\n        });\n    }\n    const enumValues = \"enumValues\" in property ? resolveEnumValues(property[\"enumValues\"] as EnumValues) : undefined;\n    if (enumValues) {\n        const newEnumValues = extractEnumFromValues(Array.from(valuesCount[\"inferred_prop\"].valuesCount.keys()));\n        return {\n            ...property,\n            enumValues: [...newEnumValues, ...enumValues]\n        } as StringProperty;\n    }\n    const generatedProperty = buildPropertyFromCount(\"inferred_prop\", data.length, property.dataType, typesCount, valuesCount[\"inferred_prop\"]);\n    return mergeDeep(generatedProperty, property);\n}\n\nexport function buildPropertiesOrder(properties: Properties<any>): string [] {\n    function propOrder(s: string) {\n        const k = s.toLowerCase();\n        if (k === \"title\" || k === \"name\") return 3;\n        if (k.includes(\"title\") || k.includes(\"name\")) return 2;\n        if (k.includes(\"image\") || k.includes(\"picture\")) return 1;\n        return 0;\n    }\n\n    const keys = Object.keys(properties);\n    keys.sort(); // alphabetically\n    keys.sort((a, b) => {\n        return propOrder(b) - propOrder(a);\n    });\n    return keys;\n}\n\n/**\n * @param type\n * @param typesCount\n * @param fieldValue\n * @param getType\n */\nfunction increaseTypeCount(type: DataType, typesCount: TypesCount, fieldValue: any, getType: InferenceTypeBuilder) {\n    if (type === \"map\") {\n        if (fieldValue) {\n            let mapTypesCount = typesCount[type];\n            if (!mapTypesCount) {\n                mapTypesCount = {};\n                typesCount[type] = mapTypesCount;\n            }\n            Object.entries(fieldValue).forEach(([key, value]) => {\n                increaseMapTypeCount(mapTypesCount as TypesCountRecord, key, value, getType);\n            })\n        }\n    } else if (type === \"array\") {\n        let arrayTypesCount = typesCount[type];\n        if (!arrayTypesCount) {\n            arrayTypesCount = {};\n            typesCount[type] = arrayTypesCount;\n        }\n        if (fieldValue && Array.isArray(fieldValue) && fieldValue.length > 0) {\n            const arrayType = getMostProbableTypeInArray(fieldValue, getType); // get type of first element\n            if (!arrayTypesCount[arrayType]) (arrayTypesCount[arrayType] as number) = 1;\n            else (arrayTypesCount[arrayType] as number)++;\n        }\n    } else {\n        if (!typesCount[type]) typesCount[type] = 1;\n        else (typesCount[type] as number)++;\n    }\n}\n\nfunction increaseMapTypeCount(\n    typesCountRecord: TypesCountRecord,\n    key: string,\n    fieldValue: any,\n    getType: InferenceTypeBuilder\n) {\n    let typesCount: TypesCount = typesCountRecord[key];\n    if (!typesCount) {\n        typesCount = {};\n        typesCountRecord[key] = typesCount;\n    }\n\n    if (fieldValue != null) { // Check that fieldValue is not null or undefined before proceeding\n        const type = getType(fieldValue);\n        increaseTypeCount(type, typesCount, fieldValue, getType);\n    }\n}\n\nfunction increaseValuesCount(\n    typeValuesRecord: ValuesCountRecord,\n    key: string,\n    fieldValue: any,\n    getType: InferenceTypeBuilder\n) {\n\n    const dataType = getType(fieldValue);\n\n    let valuesRecord: {\n        values: any[];\n        valuesCount: Map<any, number>;\n        map?: ValuesCountRecord;\n    } = typeValuesRecord[key];\n\n    if (!valuesRecord) {\n        valuesRecord = {\n            values: [],\n            valuesCount: new Map()\n        };\n        typeValuesRecord[key] = valuesRecord;\n    }\n\n    if (dataType === \"map\") {\n        let mapValuesRecord: ValuesCountRecord | undefined = valuesRecord.map;\n        if (!mapValuesRecord) {\n            mapValuesRecord = {};\n            valuesRecord.map = mapValuesRecord;\n        }\n        if (fieldValue)\n            Object.entries(fieldValue).forEach(([key, value]) => increaseValuesCount(mapValuesRecord as ValuesCountRecord, key, value, getType))\n    } else if (dataType === \"array\") {\n        if (Array.isArray(fieldValue)) {\n            fieldValue.forEach((value) => {\n                valuesRecord.values.push(value);\n                valuesRecord.valuesCount.set(value, (valuesRecord.valuesCount.get(value) ?? 0) + 1);\n            })\n        }\n    } else {\n        if (fieldValue) {\n            valuesRecord.values.push(fieldValue);\n            valuesRecord.valuesCount.set(fieldValue, (valuesRecord.valuesCount.get(fieldValue) ?? 0) + 1);\n        }\n    }\n\n}\n\nfunction getHighestTypesCount(typesCount: TypesCount): number {\n    let highestCount = 0;\n    Object.entries(typesCount).forEach(([type, count]) => {\n        let countValue = 0;\n        if (type === \"map\") {\n            countValue = getHighestRecordCount(count as TypesCountRecord);\n        } else if (type === \"array\") {\n            countValue = getHighestTypesCount(count as TypesCount);\n        } else {\n            countValue = count as number;\n        }\n        if (countValue > highestCount) {\n            highestCount = countValue;\n        }\n    });\n\n    return highestCount;\n}\n\nfunction getHighestRecordCount(record: TypesCountRecord): number {\n    return Object.entries(record)\n        .map(([key, typesCount]) => getHighestTypesCount(typesCount))\n        .reduce((a, b) => Math.max(a, b), 0);\n}\n\nfunction getMostProbableType(typesCount: TypesCount): DataType {\n    let highestCount = -1;\n    let probableType: DataType = \"string\"; //default\n    Object.entries(typesCount).forEach(([type, count]) => {\n        let countValue;\n        if (type === \"map\") {\n            countValue = getHighestRecordCount(count as TypesCountRecord);\n        } else if (type === \"array\") {\n            countValue = getHighestTypesCount(count as TypesCount);\n        } else {\n            countValue = count as number;\n        }\n        if (countValue > highestCount) {\n            highestCount = countValue;\n            probableType = type as DataType;\n        }\n    });\n    return probableType;\n}\n\nfunction buildPropertyFromCount(key: string, totalDocsCount: number, mostProbableType: DataType, typesCount: TypesCount, valuesResult?: ValuesCountEntry): Property {\n    let title: string | undefined;\n\n    if (key) {\n        title = formatString(key.toLowerCase());\n    }\n\n    let result: Property | undefined = undefined;\n    if (mostProbableType === \"map\") {\n\n        const highVariability = checkTypesCountHighVariability(typesCount);\n        if (highVariability) {\n            result = {\n                dataType: \"map\",\n                name: title,\n                keyValue: true,\n                properties: {}\n            };\n        }\n        const properties = buildPropertiesFromCount(totalDocsCount, typesCount.map as TypesCountRecord, valuesResult ? valuesResult.mapValues : undefined);\n        result = {\n            dataType: \"map\",\n            name: title,\n            properties\n        };\n    } else if (mostProbableType === \"array\") {\n        const arrayTypesCount = typesCount.array as TypesCount;\n        const arrayMostProbableType = getMostProbableType(arrayTypesCount);\n        const of = buildPropertyFromCount(key, totalDocsCount, arrayMostProbableType, arrayTypesCount, valuesResult);\n        result = {\n            dataType: \"array\",\n            name: title,\n            of\n        };\n    }\n    if (!result) {\n        const propertyProps: InferencePropertyBuilderProps = {\n            name: key,\n            totalDocsCount,\n            valuesResult\n        };\n        if (mostProbableType === \"string\") {\n            result = buildStringProperty(propertyProps);\n        } else if (mostProbableType === \"reference\") {\n            result = buildReferenceProperty(propertyProps);\n        } else {\n            result = {\n                dataType: mostProbableType\n            } as Property;\n        }\n\n        if (title) {\n            result.name = title;\n        }\n\n        const validation = buildValidation(propertyProps);\n        if (validation) {\n            result.validation = validation;\n        }\n    }\n\n    return {\n        ...result,\n        editable: true\n    };\n}\n\nfunction buildPropertiesFromCount(totalDocsCount: number, typesCountRecord: TypesCountRecord, valuesCountRecord?: ValuesCountRecord): Properties {\n    const res: Properties = {};\n    Object.entries(typesCountRecord).forEach(([key, typesCount]) => {\n        const mostProbableType = getMostProbableType(typesCount);\n        res[key] = buildPropertyFromCount(key, totalDocsCount, mostProbableType, typesCount, valuesCountRecord ? valuesCountRecord[key] : undefined);\n    })\n    return res;\n}\n\nfunction countMaxDocumentsUnder(typesCount: TypesCount) {\n    let count = 0;\n    Object.entries(typesCount).forEach(([type, value]) => {\n        // console.log(util.inspect({ type, value }, { showHidden: false, depth: null, colors: true }));\n        if (typeof value === \"object\") {\n            count = Math.max(count, countMaxDocumentsUnder(value as TypesCountRecord));\n        } else {\n            count = Math.max(count, value as number);\n        }\n    });\n    return count;\n}\n\nfunction getMostProbableTypeInArray(array: any[], getType: InferenceTypeBuilder): DataType {\n    let typesCount: TypesCount = {};\n    array.forEach((value) => {\n        increaseTypeCount(getType(value), typesCount, value, getType);\n    });\n    return getMostProbableType(typesCount);\n}\n\nfunction checkTypesCountHighVariability(typesCount: TypesCount) {\n    const maxCount = countMaxDocumentsUnder(typesCount);\n    let keysWithFewValues = 0;\n    Object.entries(typesCount.map ?? {})\n        .forEach(([key, value]) => {\n            const count = countMaxDocumentsUnder(value);\n            if (count < maxCount / 3) {\n                keysWithFewValues++;\n            }\n        });\n    return keysWithFewValues / Object.entries(typesCount.map ?? {}).length > 0.5;\n}\n\nfunction formatString(input: string): string {\n    const normalized = input\n        .replace(/[_\\-]+/g, \" \")\n        .replace(/([a-z])([A-Z])/g, \"$1 $2\")\n        .toLowerCase();\n\n    // Split the normalized string into words\n    const words = normalized.split(\" \");\n\n    // Capitalize the first letter of each word and join them with a space\n    const formatted = words\n        .map(word => word.charAt(0).toUpperCase() + word.slice(1))\n        .join(\" \");\n\n    return formatted;\n}\n\nexport function inferTypeFromValue(value: any): DataType {\n    if (typeof value === \"string\") return \"string\";\n    if (typeof value === \"number\") return \"number\";\n    if (typeof value === \"boolean\") return \"boolean\";\n    if (Array.isArray(value)) return \"array\";\n    if (typeof value === \"object\") return \"map\";\n    return \"string\";\n}\n\n"],"names":["findCommonInitialStringInPath","valuesCount","getPath","value","DocumentReference","pathWithSlash","v","s","searchedPath","path","extractEnumFromValues","values","enumValues","unslugify","a","b","IMAGE_EXTENSIONS","AUDIO_EXTENSIONS","VIDEO_EXTENSIONS","emailRegEx","buildStringProperty","totalDocsCount","valuesResult","stringProperty","totalEntriesCount","totalValues","config","probablyAURL","probablyAnEmail","probablyUserIds","fileType","probableFileType","probablyAnImage","extension","probablyAudio","probablyVideo","buildValidation","buildReferenceProperty","buildEntityPropertiesFromData","data","getType","typesCount","entry","key","increaseMapTypeCount","increaseValuesCount","buildPropertiesFromCount","buildPropertyFromData","property","increaseTypeCount","resolveEnumValues","newEnumValues","generatedProperty","buildPropertyFromCount","mergeDeep","buildPropertiesOrder","properties","propOrder","k","keys","type","fieldValue","mapTypesCount","arrayTypesCount","arrayType","getMostProbableTypeInArray","typesCountRecord","typeValuesRecord","dataType","valuesRecord","mapValuesRecord","getHighestTypesCount","highestCount","count","countValue","getHighestRecordCount","record","getMostProbableType","probableType","mostProbableType","title","formatString","result","checkTypesCountHighVariability","arrayMostProbableType","of","propertyProps","validation","valuesCountRecord","res","countMaxDocumentsUnder","array","maxCount","keysWithFewValues","input","word","inferTypeFromValue"],"mappings":"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"}