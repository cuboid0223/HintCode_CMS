{"version":3,"file":"index.es.js","sources":["../src/strings.ts","../src/util.ts","../src/builders/string_property_builder.ts","../src/builders/validation_builder.ts","../src/builders/reference_property_builder.ts","../src/collection_builder.ts"],"sourcesContent":["import { ValuesCountEntry } from \"./types\";\nimport { DocumentReference } from \"firebase/firestore\";\n\nexport function findCommonInitialStringInPath(valuesCount?: ValuesCountEntry) {\n\n    if (!valuesCount) return undefined;\n\n    function getPath(value: any) {\n        if (typeof value === \"string\") return value;\n        else if (value instanceof DocumentReference) return value.path;\n        else return undefined;\n    }\n\n    const strings: string[] = valuesCount.values.map((v) => getPath(v)).filter(v => !!v) as string[];\n    const pathWithSlash = strings.find((s) => s.includes(\"/\"));\n    if (!pathWithSlash)\n        return undefined;\n\n    const searchedPath = pathWithSlash.substr(0, pathWithSlash.lastIndexOf(\"/\"));\n\n    const yep = valuesCount.values\n        .filter((value) => {\n            const path = getPath(value);\n            if (!path) return false;\n            return path.startsWith(searchedPath)\n        }).length > valuesCount.values.length / 3 * 2;\n\n    return yep ? searchedPath : undefined;\n\n}\n\nexport function removeInitialAndTrailingSlashes(s: string): string {\n    return removeInitialSlash(removeTrailingSlash(s));\n}\n\nexport function removeInitialSlash(s: string) {\n    if (s.startsWith(\"/\"))\n        return s.slice(1);\n    else return s;\n}\n\nexport function removeTrailingSlash(s: string) {\n    if (s.endsWith(\"/\"))\n        return s.slice(0, -1);\n    else return s;\n}\n","import { unslugify } from \"@firecms/core\";\n\nexport function extractEnumFromValues(values: unknown[]) {\n    if (!Array.isArray(values)) {\n        return [];\n    }\n    const enumValues = values\n        .map((value) => {\n            if (typeof value === \"string\") {\n                return ({ id: value, label: unslugify(value) });\n            } else\n                return null;\n        }).filter(Boolean) as Array<{ id: string, label: string }>;\n    enumValues.sort((a, b) => a.label.localeCompare(b.label));\n    return enumValues;\n}\n","import { FileType, Property, StringProperty } from \"@firecms/core\";\nimport { InferencePropertyBuilderProps, ValuesCountEntry } from \"../types\";\nimport { findCommonInitialStringInPath } from \"../strings\";\nimport { extractEnumFromValues } from \"../util\";\n\nconst IMAGE_EXTENSIONS = [\".jpg\", \".png\", \".webp\", \".gif\"];\nconst AUDIO_EXTENSIONS = [\".mp3\", \".ogg\", \".opus\", \".aac\"];\nconst VIDEO_EXTENSIONS = [\".avi\", \".mp4\"];\n\nconst emailRegEx = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n\n\nexport function buildStringProperty({\n                                        totalDocsCount,\n                                        valuesResult\n                                    }: InferencePropertyBuilderProps): Property {\n\n    let stringProperty: Property = {\n        dataType: \"string\",\n\n    };\n\n    if (valuesResult) {\n\n        const totalEntriesCount = valuesResult.values.length;\n        const totalValues = Array.from(valuesResult.valuesCount.keys()).length;\n\n        const config: Partial<StringProperty> = {};\n\n        const probablyAURL = valuesResult.values\n            .filter((value) => typeof value === \"string\" &&\n                value.toString().startsWith(\"http\")).length > totalDocsCount / 3 * 2;\n        if (probablyAURL) {\n            config.url = true;\n        }\n\n        const probablyAnEmail = valuesResult.values\n            .filter((value) => typeof value === \"string\" &&\n                emailRegEx.test(value)).length > totalDocsCount / 3 * 2;\n        if (probablyAnEmail) {\n            config.email = true;\n        }\n\n        const probablyUserIds = valuesResult.values\n            .filter((value) => typeof value === \"string\" && value.length === 28 && !value.includes(\" \"))\n            .length > totalDocsCount / 3 * 2;\n        if (probablyUserIds)\n            config.readOnly = true;\n\n        if (!probablyAnEmail &&\n            !probablyAURL &&\n            !probablyUserIds &&\n            !probablyAURL &&\n            totalValues < totalEntriesCount / 3\n        ) {\n            const enumValues = extractEnumFromValues(Array.from(valuesResult.valuesCount.keys()));\n\n            if (Object.keys(enumValues).length > 1)\n                config.enumValues = enumValues;\n        }\n\n        // regular string\n        if (!probablyAnEmail &&\n            !probablyAURL &&\n            !probablyUserIds &&\n            !probablyAURL &&\n            !config.enumValues) {\n            const fileType = probableFileType(valuesResult, totalDocsCount);\n            if (fileType) {\n                config.storage = {\n                    acceptedFiles: [fileType as FileType],\n                    storagePath: findCommonInitialStringInPath(valuesResult) ?? \"/\"\n                };\n            }\n        }\n\n        if (Object.keys(config).length > 0)\n            stringProperty = {\n                ...stringProperty,\n                ...config,\n                editable: true\n            };\n    }\n\n    return stringProperty;\n}\n\n// TODO: support returning multiple types\nfunction probableFileType(valuesCount: ValuesCountEntry, totalDocsCount: number): boolean | FileType {\n    const probablyAnImage = valuesCount.values\n        .filter((value) => typeof value === \"string\" &&\n            IMAGE_EXTENSIONS.some((extension) => value.toString().endsWith(extension))).length > totalDocsCount / 3 * 2;\n\n    const probablyAudio = valuesCount.values\n        .filter((value) => typeof value === \"string\" &&\n            AUDIO_EXTENSIONS.some((extension) => value.toString().endsWith(extension))).length > totalDocsCount / 3 * 2;\n\n    const probablyVideo = valuesCount.values\n        .filter((value) => typeof value === \"string\" &&\n            VIDEO_EXTENSIONS.some((extension) => value.toString().endsWith(extension))).length > totalDocsCount / 3 * 2;\n\n    const fileType: boolean | FileType = probablyAnImage\n        ? \"image/*\"\n        : probablyAudio\n            ? \"audio/*\"\n            : probablyVideo ? \"video/*\" : false;\n    return fileType;\n}\n","import { PropertyValidationSchema } from \"@firecms/core\";\nimport { InferencePropertyBuilderProps } from \"../types\";\n\nexport function buildValidation({\n                                    totalDocsCount,\n                                    valuesResult\n                                }: InferencePropertyBuilderProps): PropertyValidationSchema | undefined {\n\n    if (valuesResult) {\n        const totalEntriesCount = valuesResult.values.length;\n        if (totalDocsCount === totalEntriesCount)\n            return {\n                required: true\n            }\n    }\n\n    return undefined;\n}\n","import { InferencePropertyBuilderProps } from \"../types\";\nimport { findCommonInitialStringInPath } from \"../strings\";\nimport { Property } from \"@firecms/core\";\n\nexport function buildReferenceProperty({\n                                        totalDocsCount,\n                                        valuesResult\n                                    }: InferencePropertyBuilderProps): Property {\n\n    const property: Property = {\n        dataType: \"reference\",\n        path: findCommonInitialStringInPath(valuesResult) ?? \"!!!FIX_ME!!!\",\n        editable: true\n    };\n\n    return property;\n}\n","import {\n    DataType,\n    EnumValues,\n    mergeDeep,\n    Properties,\n    Property,\n    resolveEnumValues,\n    StringProperty\n} from \"@firecms/core\";\nimport {\n    InferencePropertyBuilderProps,\n    TypesCount,\n    TypesCountRecord,\n    ValuesCountEntry,\n    ValuesCountRecord\n} from \"./types\";\nimport { buildStringProperty } from \"./builders/string_property_builder\";\nimport { buildValidation } from \"./builders/validation_builder\";\nimport { buildReferenceProperty } from \"./builders/reference_property_builder\";\nimport { extractEnumFromValues } from \"./util\";\n\nexport type InferenceTypeBuilder = (value: any) => DataType;\n\nexport async function buildEntityPropertiesFromData(data: object[], getType: InferenceTypeBuilder): Promise<Properties> {\n    const typesCount: TypesCountRecord = {};\n    const valuesCount: ValuesCountRecord = {};\n    if (data) {\n        data.forEach((entry) => {\n            if (entry) {\n                Object.entries(entry).forEach(([key, value]) => {\n                    increaseMapTypeCount(typesCount, key, value, getType);\n                    increaseValuesCount(valuesCount, key, value, getType);\n                })\n            }\n        });\n    }\n    // console.log(util.inspect({ typesCount }, { showHidden: false, depth: null, colors: true }));\n    return buildPropertiesFromCount(data.length, typesCount, valuesCount);\n}\n\nexport function buildPropertyFromData(data: any[], property: Property, getType: InferenceTypeBuilder): Property {\n    const typesCount = {};\n    const valuesCount: ValuesCountRecord = {};\n    if (data) {\n        data.forEach((entry) => {\n            increaseTypeCount(property.dataType, typesCount, entry, getType);\n            increaseValuesCount(valuesCount, \"inferred_prop\", entry, getType);\n        });\n    }\n    const enumValues = \"enumValues\" in property ? resolveEnumValues(property[\"enumValues\"] as EnumValues) : undefined;\n    if (enumValues) {\n        const newEnumValues = extractEnumFromValues(Array.from(valuesCount[\"inferred_prop\"].valuesCount.keys()));\n        return {\n            ...property,\n            enumValues: [...newEnumValues, ...enumValues]\n        } as StringProperty;\n    }\n    const generatedProperty = buildPropertyFromCount(\"inferred_prop\", data.length, property.dataType, typesCount, valuesCount[\"inferred_prop\"]);\n    return mergeDeep(generatedProperty, property);\n}\n\nexport function buildPropertiesOrder(properties: Properties<any>): string [] {\n    function propOrder(s: string) {\n        const k = s.toLowerCase();\n        if (k === \"title\" || k === \"name\") return 3;\n        if (k.includes(\"title\") || k.includes(\"name\")) return 2;\n        if (k.includes(\"image\") || k.includes(\"picture\")) return 1;\n        return 0;\n    }\n\n    const keys = Object.keys(properties);\n    keys.sort(); // alphabetically\n    keys.sort((a, b) => {\n        return propOrder(b) - propOrder(a);\n    });\n    return keys;\n}\n\n/**\n * @param type\n * @param typesCount\n * @param fieldValue\n * @param getType\n */\nfunction increaseTypeCount(type: DataType, typesCount: TypesCount, fieldValue: any, getType: InferenceTypeBuilder) {\n    if (type === \"map\") {\n        if (fieldValue) {\n            let mapTypesCount = typesCount[type];\n            if (!mapTypesCount) {\n                mapTypesCount = {};\n                typesCount[type] = mapTypesCount;\n            }\n            Object.entries(fieldValue).forEach(([key, value]) => {\n                increaseMapTypeCount(mapTypesCount as TypesCountRecord, key, value, getType);\n            })\n        }\n    } else if (type === \"array\") {\n        let arrayTypesCount = typesCount[type];\n        if (!arrayTypesCount) {\n            arrayTypesCount = {};\n            typesCount[type] = arrayTypesCount;\n        }\n        if (fieldValue && Array.isArray(fieldValue) && fieldValue.length > 0) {\n            const arrayType = getMostProbableTypeInArray(fieldValue, getType); // get type of first element\n            if (!arrayTypesCount[arrayType]) (arrayTypesCount[arrayType] as number) = 1;\n            else (arrayTypesCount[arrayType] as number)++;\n        }\n    } else {\n        if (!typesCount[type]) typesCount[type] = 1;\n        else (typesCount[type] as number)++;\n    }\n}\n\nfunction increaseMapTypeCount(\n    typesCountRecord: TypesCountRecord,\n    key: string,\n    fieldValue: any,\n    getType: InferenceTypeBuilder\n) {\n    let typesCount: TypesCount = typesCountRecord[key];\n    if (!typesCount) {\n        typesCount = {};\n        typesCountRecord[key] = typesCount;\n    }\n\n    if (fieldValue != null) { // Check that fieldValue is not null or undefined before proceeding\n        const type = getType(fieldValue);\n        increaseTypeCount(type, typesCount, fieldValue, getType);\n    }\n}\n\nfunction increaseValuesCount(\n    typeValuesRecord: ValuesCountRecord,\n    key: string,\n    fieldValue: any,\n    getType: InferenceTypeBuilder\n) {\n\n    const dataType = getType(fieldValue);\n\n    let valuesRecord: {\n        values: any[];\n        valuesCount: Map<any, number>;\n        map?: ValuesCountRecord;\n    } = typeValuesRecord[key];\n\n    if (!valuesRecord) {\n        valuesRecord = {\n            values: [],\n            valuesCount: new Map()\n        };\n        typeValuesRecord[key] = valuesRecord;\n    }\n\n    if (dataType === \"map\") {\n        let mapValuesRecord: ValuesCountRecord | undefined = valuesRecord.map;\n        if (!mapValuesRecord) {\n            mapValuesRecord = {};\n            valuesRecord.map = mapValuesRecord;\n        }\n        if (fieldValue)\n            Object.entries(fieldValue).forEach(([key, value]) => increaseValuesCount(mapValuesRecord as ValuesCountRecord, key, value, getType))\n    } else if (dataType === \"array\") {\n        if (Array.isArray(fieldValue)) {\n            fieldValue.forEach((value) => {\n                valuesRecord.values.push(value);\n                valuesRecord.valuesCount.set(value, (valuesRecord.valuesCount.get(value) ?? 0) + 1);\n            })\n        }\n    } else {\n        if (fieldValue) {\n            valuesRecord.values.push(fieldValue);\n            valuesRecord.valuesCount.set(fieldValue, (valuesRecord.valuesCount.get(fieldValue) ?? 0) + 1);\n        }\n    }\n\n}\n\nfunction getHighestTypesCount(typesCount: TypesCount): number {\n    let highestCount = 0;\n    Object.entries(typesCount).forEach(([type, count]) => {\n        let countValue = 0;\n        if (type === \"map\") {\n            countValue = getHighestRecordCount(count as TypesCountRecord);\n        } else if (type === \"array\") {\n            countValue = getHighestTypesCount(count as TypesCount);\n        } else {\n            countValue = count as number;\n        }\n        if (countValue > highestCount) {\n            highestCount = countValue;\n        }\n    });\n\n    return highestCount;\n}\n\nfunction getHighestRecordCount(record: TypesCountRecord): number {\n    return Object.entries(record)\n        .map(([key, typesCount]) => getHighestTypesCount(typesCount))\n        .reduce((a, b) => Math.max(a, b), 0);\n}\n\nfunction getMostProbableType(typesCount: TypesCount): DataType {\n    let highestCount = -1;\n    let probableType: DataType = \"string\"; //default\n    Object.entries(typesCount).forEach(([type, count]) => {\n        let countValue;\n        if (type === \"map\") {\n            countValue = getHighestRecordCount(count as TypesCountRecord);\n        } else if (type === \"array\") {\n            countValue = getHighestTypesCount(count as TypesCount);\n        } else {\n            countValue = count as number;\n        }\n        if (countValue > highestCount) {\n            highestCount = countValue;\n            probableType = type as DataType;\n        }\n    });\n    return probableType;\n}\n\nfunction buildPropertyFromCount(key: string, totalDocsCount: number, mostProbableType: DataType, typesCount: TypesCount, valuesResult?: ValuesCountEntry): Property {\n    let title: string | undefined;\n\n    if (key) {\n        title = formatString(key.toLowerCase());\n    }\n\n    let result: Property | undefined = undefined;\n    if (mostProbableType === \"map\") {\n\n        const highVariability = checkTypesCountHighVariability(typesCount);\n        if (highVariability) {\n            result = {\n                dataType: \"map\",\n                name: title,\n                keyValue: true,\n                properties: {}\n            };\n        }\n        const properties = buildPropertiesFromCount(totalDocsCount, typesCount.map as TypesCountRecord, valuesResult ? valuesResult.mapValues : undefined);\n        result = {\n            dataType: \"map\",\n            name: title,\n            properties\n        };\n    } else if (mostProbableType === \"array\") {\n        const arrayTypesCount = typesCount.array as TypesCount;\n        const arrayMostProbableType = getMostProbableType(arrayTypesCount);\n        const of = buildPropertyFromCount(key, totalDocsCount, arrayMostProbableType, arrayTypesCount, valuesResult);\n        result = {\n            dataType: \"array\",\n            name: title,\n            of\n        };\n    }\n    if (!result) {\n        const propertyProps: InferencePropertyBuilderProps = {\n            name: key,\n            totalDocsCount,\n            valuesResult\n        };\n        if (mostProbableType === \"string\") {\n            result = buildStringProperty(propertyProps);\n        } else if (mostProbableType === \"reference\") {\n            result = buildReferenceProperty(propertyProps);\n        } else {\n            result = {\n                dataType: mostProbableType\n            } as Property;\n        }\n\n        if (title) {\n            result.name = title;\n        }\n\n        const validation = buildValidation(propertyProps);\n        if (validation) {\n            result.validation = validation;\n        }\n    }\n\n    return {\n        ...result,\n        editable: true\n    };\n}\n\nfunction buildPropertiesFromCount(totalDocsCount: number, typesCountRecord: TypesCountRecord, valuesCountRecord?: ValuesCountRecord): Properties {\n    const res: Properties = {};\n    Object.entries(typesCountRecord).forEach(([key, typesCount]) => {\n        const mostProbableType = getMostProbableType(typesCount);\n        res[key] = buildPropertyFromCount(key, totalDocsCount, mostProbableType, typesCount, valuesCountRecord ? valuesCountRecord[key] : undefined);\n    })\n    return res;\n}\n\nfunction countMaxDocumentsUnder(typesCount: TypesCount) {\n    let count = 0;\n    Object.entries(typesCount).forEach(([type, value]) => {\n        // console.log(util.inspect({ type, value }, { showHidden: false, depth: null, colors: true }));\n        if (typeof value === \"object\") {\n            count = Math.max(count, countMaxDocumentsUnder(value as TypesCountRecord));\n        } else {\n            count = Math.max(count, value as number);\n        }\n    });\n    return count;\n}\n\nfunction getMostProbableTypeInArray(array: any[], getType: InferenceTypeBuilder): DataType {\n    let typesCount: TypesCount = {};\n    array.forEach((value) => {\n        increaseTypeCount(getType(value), typesCount, value, getType);\n    });\n    return getMostProbableType(typesCount);\n}\n\nfunction checkTypesCountHighVariability(typesCount: TypesCount) {\n    const maxCount = countMaxDocumentsUnder(typesCount);\n    let keysWithFewValues = 0;\n    Object.entries(typesCount.map ?? {})\n        .forEach(([key, value]) => {\n            const count = countMaxDocumentsUnder(value);\n            if (count < maxCount / 3) {\n                keysWithFewValues++;\n            }\n        });\n    return keysWithFewValues / Object.entries(typesCount.map ?? {}).length > 0.5;\n}\n\nfunction formatString(input: string): string {\n    const normalized = input\n        .replace(/[_\\-]+/g, \" \")\n        .replace(/([a-z])([A-Z])/g, \"$1 $2\")\n        .toLowerCase();\n\n    // Split the normalized string into words\n    const words = normalized.split(\" \");\n\n    // Capitalize the first letter of each word and join them with a space\n    const formatted = words\n        .map(word => word.charAt(0).toUpperCase() + word.slice(1))\n        .join(\" \");\n\n    return formatted;\n}\n\nexport function inferTypeFromValue(value: any): DataType {\n    if (typeof value === \"string\") return \"string\";\n    if (typeof value === \"number\") return \"number\";\n    if (typeof value === \"boolean\") return \"boolean\";\n    if (Array.isArray(value)) return \"array\";\n    if (typeof value === \"object\") return \"map\";\n    return \"string\";\n}\n\n"],"names":["findCommonInitialStringInPath","valuesCount","getPath","value","DocumentReference","pathWithSlash","v","s","searchedPath","path","extractEnumFromValues","values","enumValues","unslugify","a","b","IMAGE_EXTENSIONS","AUDIO_EXTENSIONS","VIDEO_EXTENSIONS","emailRegEx","buildStringProperty","totalDocsCount","valuesResult","stringProperty","totalEntriesCount","totalValues","config","probablyAURL","probablyAnEmail","probablyUserIds","fileType","probableFileType","probablyAnImage","extension","probablyAudio","probablyVideo","buildValidation","buildReferenceProperty","buildEntityPropertiesFromData","data","getType","typesCount","entry","key","increaseMapTypeCount","increaseValuesCount","buildPropertiesFromCount","buildPropertyFromData","property","increaseTypeCount","resolveEnumValues","newEnumValues","generatedProperty","buildPropertyFromCount","mergeDeep","buildPropertiesOrder","properties","propOrder","k","keys","type","fieldValue","mapTypesCount","arrayTypesCount","arrayType","getMostProbableTypeInArray","typesCountRecord","typeValuesRecord","dataType","valuesRecord","mapValuesRecord","getHighestTypesCount","highestCount","count","countValue","getHighestRecordCount","record","getMostProbableType","probableType","mostProbableType","title","formatString","result","checkTypesCountHighVariability","arrayMostProbableType","of","propertyProps","validation","valuesCountRecord","res","countMaxDocumentsUnder","array","maxCount","keysWithFewValues","input","word","inferTypeFromValue"],"mappings":";;AAGO,SAASA,EAA8BC,GAAgC;AAE1E,MAAI,CAACA;AAAoB;AAEzB,WAASC,EAAQC,GAAY;AACzB,WAAI,OAAOA,KAAU,WAAiBA,IAC7BA,aAAiBC,IAA0BD,EAAM,OAC9C;AAAA,EAChB;AAGM,QAAAE,IADoBJ,EAAY,OAAO,IAAI,CAACK,MAAMJ,EAAQI,CAAC,CAAC,EAAE,OAAO,CAAKA,MAAA,CAAC,CAACA,CAAC,EACrD,KAAK,CAACC,MAAMA,EAAE,SAAS,GAAG,CAAC;AACzD,MAAI,CAACF;AACM;AAEX,QAAMG,IAAeH,EAAc,OAAO,GAAGA,EAAc,YAAY,GAAG,CAAC;AAS3E,SAPYJ,EAAY,OACnB,OAAO,CAACE,MAAU;AACT,UAAAM,IAAOP,EAAQC,CAAK;AAC1B,WAAKM,IACEA,EAAK,WAAWD,CAAY,IADjB;AAAA,EACiB,CACtC,EAAE,SAASP,EAAY,OAAO,SAAS,IAAI,IAEnCO,IAAe;AAEhC;AC3BO,SAASE,EAAsBC,GAAmB;AACrD,MAAI,CAAC,MAAM,QAAQA,CAAM;AACrB,WAAO;AAEX,QAAMC,IAAaD,EACd,IAAI,CAACR,MACE,OAAOA,KAAU,WACT,EAAE,IAAIA,GAAO,OAAOU,EAAUV,CAAK,MAEpC,IACd,EAAE,OAAO,OAAO;AACV,SAAAS,EAAA,KAAK,CAACE,GAAGC,MAAMD,EAAE,MAAM,cAAcC,EAAE,KAAK,CAAC,GACjDH;AACX;ACVA,MAAMI,IAAmB,CAAC,QAAQ,QAAQ,SAAS,MAAM,GACnDC,IAAmB,CAAC,QAAQ,QAAQ,SAAS,MAAM,GACnDC,IAAmB,CAAC,QAAQ,MAAM,GAElCC,IAAa;AAGZ,SAASC,EAAoB;AAAA,EACI,gBAAAC;AAAA,EACA,cAAAC;AACJ,GAA4C;AAE5E,MAAIC,IAA2B;AAAA,IAC3B,UAAU;AAAA,EAAA;AAId,MAAID,GAAc;AAER,UAAAE,IAAoBF,EAAa,OAAO,QACxCG,IAAc,MAAM,KAAKH,EAAa,YAAY,KAAA,CAAM,EAAE,QAE1DI,IAAkC,CAAA,GAElCC,IAAeL,EAAa,OAC7B,OAAO,CAACnB,MAAU,OAAOA,KAAU,YAChCA,EAAM,WAAW,WAAW,MAAM,CAAC,EAAE,SAASkB,IAAiB,IAAI;AAC3E,IAAIM,MACAD,EAAO,MAAM;AAGjB,UAAME,IAAkBN,EAAa,OAChC,OAAO,CAACnB,MAAU,OAAOA,KAAU,YAChCgB,EAAW,KAAKhB,CAAK,CAAC,EAAE,SAASkB,IAAiB,IAAI;AAC9D,IAAIO,MACAF,EAAO,QAAQ;AAGb,UAAAG,IAAkBP,EAAa,OAChC,OAAO,CAACnB,MAAU,OAAOA,KAAU,YAAYA,EAAM,WAAW,MAAM,CAACA,EAAM,SAAS,GAAG,CAAC,EAC1F,SAASkB,IAAiB,IAAI;AAI/B,QAHAQ,MACAH,EAAO,WAAW,KAElB,CAACE,KACD,CAACD,KACD,CAACE,KACD,CAACF,KACDF,IAAcD,IAAoB,GACpC;AACQ,YAAAZ,IAAaF,EAAsB,MAAM,KAAKY,EAAa,YAAY,KAAM,CAAA,CAAC;AAEpF,MAAI,OAAO,KAAKV,CAAU,EAAE,SAAS,MACjCc,EAAO,aAAad;AAAA,IAC5B;AAGI,QAAA,CAACgB,KACD,CAACD,KACD,CAACE,KACD,CAACF,KACD,CAACD,EAAO,YAAY;AACd,YAAAI,IAAWC,EAAiBT,GAAcD,CAAc;AAC9D,MAAIS,MACAJ,EAAO,UAAU;AAAA,QACb,eAAe,CAACI,CAAoB;AAAA,QACpC,aAAa9B,EAA8BsB,CAAY,KAAK;AAAA,MAAA;AAAA,IAGxE;AAEA,IAAI,OAAO,KAAKI,CAAM,EAAE,SAAS,MACZH,IAAA;AAAA,MACb,GAAGA;AAAA,MACH,GAAGG;AAAA,MACH,UAAU;AAAA,IAAA;AAAA,EAEtB;AAEO,SAAAH;AACX;AAGA,SAASQ,EAAiB9B,GAA+BoB,GAA4C;AAC3F,QAAAW,IAAkB/B,EAAY,OAC/B,OAAO,CAACE,MAAU,OAAOA,KAAU,YAChCa,EAAiB,KAAK,CAACiB,MAAc9B,EAAM,WAAW,SAAS8B,CAAS,CAAC,CAAC,EAAE,SAASZ,IAAiB,IAAI,GAE5Ga,IAAgBjC,EAAY,OAC7B,OAAO,CAACE,MAAU,OAAOA,KAAU,YAChCc,EAAiB,KAAK,CAACgB,MAAc9B,EAAM,WAAW,SAAS8B,CAAS,CAAC,CAAC,EAAE,SAASZ,IAAiB,IAAI,GAE5Gc,IAAgBlC,EAAY,OAC7B,OAAO,CAACE,MAAU,OAAOA,KAAU,YAChCe,EAAiB,KAAK,CAACe,MAAc9B,EAAM,WAAW,SAAS8B,CAAS,CAAC,CAAC,EAAE,SAASZ,IAAiB,IAAI;AAO3G,SAL8BW,IAC/B,YACAE,IACI,YACAC,IAAgB,YAAY;AAE1C;ACxGO,SAASC,EAAgB;AAAA,EACI,gBAAAf;AAAA,EACA,cAAAC;AACJ,GAAwE;AAEpG,MAAIA,GAAc;AACR,UAAAE,IAAoBF,EAAa,OAAO;AAC9C,QAAID,MAAmBG;AACZ,aAAA;AAAA,QACH,UAAU;AAAA,MAAA;AAAA,EAEtB;AAGJ;ACbO,SAASa,EAAuB;AAAA,EACC,gBAAAhB;AAAA,EACA,cAAAC;AACJ,GAA4C;AAQrE,SANoB;AAAA,IACvB,UAAU;AAAA,IACV,MAAMtB,EAA8BsB,CAAY,KAAK;AAAA,IACrD,UAAU;AAAA,EAAA;AAIlB;ACOsB,eAAAgB,EAA8BC,GAAgBC,GAAoD;AACpH,QAAMC,IAA+B,CAAA,GAC/BxC,IAAiC,CAAA;AACvC,SAAIsC,KACKA,EAAA,QAAQ,CAACG,MAAU;AACpB,IAAIA,KACO,OAAA,QAAQA,CAAK,EAAE,QAAQ,CAAC,CAACC,GAAKxC,CAAK,MAAM;AACvB,MAAAyC,EAAAH,GAAYE,GAAKxC,GAAOqC,CAAO,GAChCK,EAAA5C,GAAa0C,GAAKxC,GAAOqC,CAAO;AAAA,IAAA,CACvD;AAAA,EACL,CACH,GAGEM,EAAyBP,EAAK,QAAQE,GAAYxC,CAAW;AACxE;AAEgB,SAAA8C,EAAsBR,GAAaS,GAAoBR,GAAyC;AAC5G,QAAMC,IAAa,CAAA,GACbxC,IAAiC,CAAA;AACvC,EAAIsC,KACKA,EAAA,QAAQ,CAACG,MAAU;AACpB,IAAAO,EAAkBD,EAAS,UAAUP,GAAYC,GAAOF,CAAO,GAC3CK,EAAA5C,GAAa,iBAAiByC,GAAOF,CAAO;AAAA,EAAA,CACnE;AAEL,QAAM5B,IAAa,gBAAgBoC,IAAWE,EAAkBF,EAAS,UAA2B,IAAI;AACxG,MAAIpC,GAAY;AACN,UAAAuC,IAAgBzC,EAAsB,MAAM,KAAKT,EAAY,cAAiB,YAAY,KAAM,CAAA,CAAC;AAChG,WAAA;AAAA,MACH,GAAG+C;AAAA,MACH,YAAY,CAAC,GAAGG,GAAe,GAAGvC,CAAU;AAAA,IAAA;AAAA,EAEpD;AACM,QAAAwC,IAAoBC,EAAuB,iBAAiBd,EAAK,QAAQS,EAAS,UAAUP,GAAYxC,EAAY,aAAgB;AACnI,SAAAqD,EAAUF,GAAmBJ,CAAQ;AAChD;AAEO,SAASO,EAAqBC,GAAwC;AACzE,WAASC,EAAU,GAAW;AACpB,UAAAC,IAAI,EAAE;AACR,WAAAA,MAAM,WAAWA,MAAM,SAAe,IACtCA,EAAE,SAAS,OAAO,KAAKA,EAAE,SAAS,MAAM,IAAU,IAClDA,EAAE,SAAS,OAAO,KAAKA,EAAE,SAAS,SAAS,IAAU,IAClD;AAAA,EACX;AAEM,QAAAC,IAAO,OAAO,KAAKH,CAAU;AACnC,SAAAG,EAAK,KAAK,GACLA,EAAA,KAAK,CAAC7C,GAAGC,MACH0C,EAAU1C,CAAC,IAAI0C,EAAU3C,CAAC,CACpC,GACM6C;AACX;AAQA,SAASV,EAAkBW,GAAgBnB,GAAwBoB,GAAiBrB,GAA+B;AAC/G,MAAIoB,MAAS;AACT,QAAIC,GAAY;AACR,UAAAC,IAAgBrB,EAAWmB,CAAI;AACnC,MAAKE,MACDA,IAAgB,CAAA,GAChBrB,EAAWmB,CAAI,IAAIE,IAEhB,OAAA,QAAQD,CAAU,EAAE,QAAQ,CAAC,CAAClB,GAAKxC,CAAK,MAAM;AAC5B,QAAAyC,EAAAkB,GAAmCnB,GAAKxC,GAAOqC,CAAO;AAAA,MAAA,CAC9E;AAAA,IACL;AAAA,aACOoB,MAAS,SAAS;AACrB,QAAAG,IAAkBtB,EAAWmB,CAAI;AAKrC,QAJKG,MACDA,IAAkB,CAAA,GAClBtB,EAAWmB,CAAI,IAAIG,IAEnBF,KAAc,MAAM,QAAQA,CAAU,KAAKA,EAAW,SAAS,GAAG;AAC5D,YAAAG,IAAYC,EAA2BJ,GAAYrB,CAAO;AAC5D,MAACuB,EAAgBC,CAAS,IACxBD,EAAgBC,CAAS,MADGD,EAAgBC,CAAS,IAAe;AAAA,IAE9E;AAAA,EAAA;AAEI,IAACvB,EAAWmB,CAAI,IACdnB,EAAWmB,CAAI,MADEnB,EAAWmB,CAAI,IAAI;AAGlD;AAEA,SAAShB,EACLsB,GACAvB,GACAkB,GACArB,GACF;AACM,MAAAC,IAAyByB,EAAiBvB,CAAG;AAMjD,MALKF,MACDA,IAAa,CAAA,GACbyB,EAAiBvB,CAAG,IAAIF,IAGxBoB,KAAc,MAAM;AACd,UAAAD,IAAOpB,EAAQqB,CAAU;AACb,IAAAZ,EAAAW,GAAMnB,GAAYoB,GAAYrB,CAAO;AAAA,EAC3D;AACJ;AAEA,SAASK,EACLsB,GACAxB,GACAkB,GACArB,GACF;AAEQ,QAAA4B,IAAW5B,EAAQqB,CAAU;AAE/B,MAAAQ,IAIAF,EAAiBxB,CAAG;AAUxB,MARK0B,MACcA,IAAA;AAAA,IACX,QAAQ,CAAC;AAAA,IACT,iCAAiB,IAAI;AAAA,EAAA,GAEzBF,EAAiBxB,CAAG,IAAI0B,IAGxBD,MAAa,OAAO;AACpB,QAAIE,IAAiDD,EAAa;AAClE,IAAKC,MACDA,IAAkB,CAAA,GAClBD,EAAa,MAAMC,IAEnBT,KACA,OAAO,QAAQA,CAAU,EAAE,QAAQ,CAAC,CAAClB,GAAKxC,CAAK,MAAM0C,EAAoByB,GAAsC3B,GAAKxC,GAAOqC,CAAO,CAAC;AAAA,EAAA;AAC3I,IAAW4B,MAAa,UAChB,MAAM,QAAQP,CAAU,KACbA,EAAA,QAAQ,CAAC1D,MAAU;AACb,MAAAkE,EAAA,OAAO,KAAKlE,CAAK,GACjBkE,EAAA,YAAY,IAAIlE,IAAQkE,EAAa,YAAY,IAAIlE,CAAK,KAAK,KAAK,CAAC;AAAA,IAAA,CACrF,IAGD0D,MACaQ,EAAA,OAAO,KAAKR,CAAU,GACtBQ,EAAA,YAAY,IAAIR,IAAaQ,EAAa,YAAY,IAAIR,CAAU,KAAK,KAAK,CAAC;AAIxG;AAEA,SAASU,EAAqB9B,GAAgC;AAC1D,MAAI+B,IAAe;AACZ,gBAAA,QAAQ/B,CAAU,EAAE,QAAQ,CAAC,CAACmB,GAAMa,CAAK,MAAM;AAClD,QAAIC,IAAa;AACjB,IAAId,MAAS,QACTc,IAAaC,EAAsBF,CAAyB,IACrDb,MAAS,UAChBc,IAAaH,EAAqBE,CAAmB,IAExCC,IAAAD,GAEbC,IAAaF,MACEA,IAAAE;AAAA,EACnB,CACH,GAEMF;AACX;AAEA,SAASG,EAAsBC,GAAkC;AACtD,SAAA,OAAO,QAAQA,CAAM,EACvB,IAAI,CAAC,CAACjC,GAAKF,CAAU,MAAM8B,EAAqB9B,CAAU,CAAC,EAC3D,OAAO,CAAC3B,GAAGC,MAAM,KAAK,IAAID,GAAGC,CAAC,GAAG,CAAC;AAC3C;AAEA,SAAS8D,EAAoBpC,GAAkC;AAC3D,MAAI+B,IAAe,IACfM,IAAyB;AACtB,gBAAA,QAAQrC,CAAU,EAAE,QAAQ,CAAC,CAACmB,GAAMa,CAAK,MAAM;AAC9C,QAAAC;AACJ,IAAId,MAAS,QACTc,IAAaC,EAAsBF,CAAyB,IACrDb,MAAS,UAChBc,IAAaH,EAAqBE,CAAmB,IAExCC,IAAAD,GAEbC,IAAaF,MACEA,IAAAE,GACAI,IAAAlB;AAAA,EACnB,CACH,GACMkB;AACX;AAEA,SAASzB,EAAuBV,GAAatB,GAAwB0D,GAA4BtC,GAAwBnB,GAA2C;AAC5J,MAAA0D;AAEJ,EAAIrC,MACQqC,IAAAC,EAAatC,EAAI,YAAa,CAAA;AAG1C,MAAIuC;AACJ,MAAIH,MAAqB,OAAO;AAG5B,IADwBI,EAA+B1C,CAAU,MAEpDyC,IAAA;AAAA,MACL,UAAU;AAAA,MACV,MAAMF;AAAA,MACN,UAAU;AAAA,MACV,YAAY,CAAC;AAAA,IAAA;AAGf,UAAAxB,IAAaV,EAAyBzB,GAAgBoB,EAAW,KAAyBnB,IAAeA,EAAa,YAAY,MAAS;AACxI,IAAA4D,IAAA;AAAA,MACL,UAAU;AAAA,MACV,MAAMF;AAAA,MACN,YAAAxB;AAAA,IAAA;AAAA,EACJ,WACOuB,MAAqB,SAAS;AACrC,UAAMhB,IAAkBtB,EAAW,OAC7B2C,IAAwBP,EAAoBd,CAAe,GAC3DsB,IAAKhC,EAAuBV,GAAKtB,GAAgB+D,GAAuBrB,GAAiBzC,CAAY;AAClG,IAAA4D,IAAA;AAAA,MACL,UAAU;AAAA,MACV,MAAMF;AAAA,MACN,IAAAK;AAAA,IAAA;AAAA,EAER;AACA,MAAI,CAACH,GAAQ;AACT,UAAMI,IAA+C;AAAA,MACjD,MAAM3C;AAAA,MACN,gBAAAtB;AAAA,MACA,cAAAC;AAAA,IAAA;AAEJ,IAAIyD,MAAqB,WACrBG,IAAS9D,EAAoBkE,CAAa,IACnCP,MAAqB,cAC5BG,IAAS7C,EAAuBiD,CAAa,IAEpCJ,IAAA;AAAA,MACL,UAAUH;AAAA,IAAA,GAIdC,MACAE,EAAO,OAAOF;AAGZ,UAAAO,IAAanD,EAAgBkD,CAAa;AAChD,IAAIC,MACAL,EAAO,aAAaK;AAAA,EAE5B;AAEO,SAAA;AAAA,IACH,GAAGL;AAAA,IACH,UAAU;AAAA,EAAA;AAElB;AAEA,SAASpC,EAAyBzB,GAAwB6C,GAAoCsB,GAAmD;AAC7I,QAAMC,IAAkB,CAAA;AACjB,gBAAA,QAAQvB,CAAgB,EAAE,QAAQ,CAAC,CAACvB,GAAKF,CAAU,MAAM;AACtD,UAAAsC,IAAmBF,EAAoBpC,CAAU;AACnD,IAAAgD,EAAA9C,CAAG,IAAIU,EAAuBV,GAAKtB,GAAgB0D,GAAkBtC,GAAY+C,IAAoBA,EAAkB7C,CAAG,IAAI,MAAS;AAAA,EAAA,CAC9I,GACM8C;AACX;AAEA,SAASC,EAAuBjD,GAAwB;AACpD,MAAIgC,IAAQ;AACL,gBAAA,QAAQhC,CAAU,EAAE,QAAQ,CAAC,CAACmB,GAAMzD,CAAK,MAAM;AAE9C,IAAA,OAAOA,KAAU,WACjBsE,IAAQ,KAAK,IAAIA,GAAOiB,EAAuBvF,CAAyB,CAAC,IAEjEsE,IAAA,KAAK,IAAIA,GAAOtE,CAAe;AAAA,EAC3C,CACH,GACMsE;AACX;AAEA,SAASR,EAA2B0B,GAAcnD,GAAyC;AACvF,MAAIC,IAAyB,CAAA;AACvB,SAAAkD,EAAA,QAAQ,CAACxF,MAAU;AACrB,IAAA8C,EAAkBT,EAAQrC,CAAK,GAAGsC,GAAYtC,GAAOqC,CAAO;AAAA,EAAA,CAC/D,GACMqC,EAAoBpC,CAAU;AACzC;AAEA,SAAS0C,EAA+B1C,GAAwB;AACtD,QAAAmD,IAAWF,EAAuBjD,CAAU;AAClD,MAAIoD,IAAoB;AACjB,gBAAA,QAAQpD,EAAW,OAAO,CAAA,CAAE,EAC9B,QAAQ,CAAC,CAACE,GAAKxC,CAAK,MAAM;AAEnB,IADUuF,EAAuBvF,CAAK,IAC9ByF,IAAW,KACnBC;AAAA,EACJ,CACH,GACEA,IAAoB,OAAO,QAAQpD,EAAW,OAAO,CAAE,CAAA,EAAE,SAAS;AAC7E;AAEA,SAASwC,EAAaa,GAAuB;AAclC,SAbYA,EACd,QAAQ,WAAW,GAAG,EACtB,QAAQ,mBAAmB,OAAO,EAClC,YAAY,EAGQ,MAAM,GAAG,EAI7B,IAAI,CAAQC,MAAAA,EAAK,OAAO,CAAC,EAAE,YAAY,IAAIA,EAAK,MAAM,CAAC,CAAC,EACxD,KAAK,GAAG;AAGjB;AAEO,SAASC,EAAmB7F,GAAsB;AACrD,SAAI,OAAOA,KAAU,WAAiB,WAClC,OAAOA,KAAU,WAAiB,WAClC,OAAOA,KAAU,YAAkB,YACnC,MAAM,QAAQA,CAAK,IAAU,UAC7B,OAAOA,KAAU,WAAiB,QAC/B;AACX;"}